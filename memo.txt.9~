##### PHPフレームワーク　Lravel入門 第2版 （掌田先生）########################
/*
よく登場する<style>タグ

<style>
body {
  font-size: 16pt;
  color: #999;
}
h1 {
  font-size: 100pt;
  text-align: right;
  color: #f6f6f6;
  margin: -50px 0 -100px 0px;
}
</style>

*/

Chapter 1 Laravelを準備する

Chapter 2 ルーティングとコントローラ

＠ルーティング
特定のアドレスにアクセスしたときに、どの処理を呼び出して実行するかを管理するの
が「ルーティング」。
==================================

＠Laravelのファイルについて
.editorConfig
エディタに関する汎用設定ファイル
-----------------
.env、.env.example
動作kな教に関する設定情報
-----------------
.gitattributes、gitignore
Git利用に関する情報
-----------------
.styleci.yml
StyleCIコードチェッカーのファイル
-----------------
artisan
artisanコマンド
-----------------
composer.json、composer.lock
composerの利用に関するもの
-----------------
package.json、package-lock.json
JavaScriptのパッケージ管理ツール（npm）で利用するもの
-----------------
phpunit.xml
PHPUnitに関するもの
-----------------
server.php
サーバ起動時に利用されるプログラム
-----------------
yarn.lock
yarnというパッケージマネージャが使うファイル（自動生成される）
==================================

＠Laravelのフォルダ
app
アプリケーションのプログラム部分がまとめられるところ。
ここにスクリプトファイルを追加していく。
-----------------
bootstrap
アプリケーション実行時に最初に行われる処理がまとめられている。
-----------------
config
設定関係のファイルがまとめられている
-----------------
database
データベース関連のファイルがまとめられている
-----------------
public
公開フォルダ。
JavaScriptやスタイルシートなど、外部にそのまま公開されるファイルがまとめられて
いる。
-----------------
resources
リソース関係の配置場所。
プログラムが利用するリソースファイルが用意される。
テンプレートファイルなどが用意される。
-----------------
routes
ルート情報の保存場所。
アクセスするアドレスに割り当てられるプログラムの情報などが記されている。
-----------------
storage
ファイルの保存場所。
アプリケーションのプログラムが保存するファイルなどが置かれる。
ログファイルなどはここに保存される。
-----------------
tests
ユニットテスト関係のファイルが用意される。
-----------------
vendor
フレームワーク本体のプログラムがまとめられている。
==================================

＠appフォルダについて
Laravelアップロードに用意されているフォルダの中で、もっとも重要で利用頻度が高
いのがappフォルダ。
appフォルダは、Laravelアプリケーションの「アプリケーション」部分のプログラムが
配置される。
----------------------------------
■appフォルダ内のフォルダ
Console
コンソールプログラムを配置。
-----------------
Exceptions
例外に関する処理を配置。
-----------------
Http
ウェブアプリケーションにアクセスしたときの処理をまとめておくところ。
アプリケーションの基本転記なプログラムはここに作成。
-----------------
Providers
プロバイダと呼ばれるプログラムを配置。
-----------------
User.php
ユーザ認証に関するスクリプト。
==================================

＠ルーティングと「routes」フォルダ
Laravelは、特定のアドレスにアクセスすると、そのアドレスに割り付けられたプログ
ラムが実行され、それによって必要な処理や画面表示が行われる。
-----------------
このように「○○というアドレスにアクセスしたら、××という処理を呼び出す」とい
う関連付けを行っているのが「ルーティング」。
ルーティングは、アクセスを設定している情報（ルート）を管理する機能。
==================================

＠routesフォルダ
デフォルトでいくつかのスクリプトファイルが用意されエイル。
-----------------
api.php
APIのルーティング。
ユーザ認証等のように、プログラム内から利用するAPIの機能を特定のアドレスに割り
当てるのに利用される。
-----------------
channels.php
ブロードキャストチャンネルのためのルーティング。
-----------------
console.php
コンソールプログラムのためのルーティング。
-----------------
web.php
一般的なWebページとしてアクセスするためのルーティング。
----------------------------------
基本的にWebページとして公開するものは、web.phpにルート情報を記述する。
==================================

＠ルート情報の記述
/* routes/web.php */
<?php
Route::get('/'', function() {
  return view('welcome');
});
----------------------------------
■ルート情報の基本（GETアクセス）
Route::get(アドレス, 関数など);
-----------------
GETアクセスのルート情報は、Routeクラスのget静的メソッドで設定する。
第1引数に割り当てるアドレスを、第2引数にそれにより呼び出される処理。
第2引数には、関数を指定することも「コントローラ」を指定することもある。
==================================

＠トップページのルート情報
第1引数は'/'、例では第2引数は関数となっている。
-----------------
function() {
  return 値;
}
-----------------
引数なしのクロージャ（無名関数）となっている。
returnされる値がそのアドレスにアクセスした際に表示される内容となる。
この例では、view関数を使って戻り値を用意している。
-----------------
view(テンプレート名)
-----------------
viewは、指定したテンプレートファイルをロードし、レンダリングして返す働きをする
。
viewで引数にテンプレートを指定すると、それがレンダリングされて返され、ブラウザ
に表示さえる。
----------------------------------
■welcomeテンプレートについて
return view('welcome');
で、welcome.blade.phpテンプレートファイルをレンダリングして表示する。
-----------------
テンプレートファイルは、resources/viewsフォルダに配置。
-----------------
/* resources/views/welcome.blade.php */
<!doctype html>
<html lang="{{ app()->getLocale() }}">
  <head>
    <meta charset="utf-8">
    <!-- バージョン8以降のIEで使用できる互換モード -->
    <meta http-equive="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Laravel</title>

    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css?family=Nunito:200,600" rel="stylesheet">
 
    <!-- Styles -->
    <style>
        html, body {
            background-color: #fff;
            color: #636b6f;
            font-family: 'Nunito', sans-serif;
            font-weight: 200;
            height: 100vh;
            margin: 0;
        }
 
        .full-height {
            height: 100vh;
        }
 
        .flex-center {
            align-items: center;
            display: flex;
            justify-content: center;
        }
 
        .position-ref {
            position: relative;
        }
 
        .top-right {
            position: absolute;
            right: 10px;
            top: 18px;
        }
 
        .content {
            text-align: center;
        }
 
        .title {
            font-size: 84px;
        }
 
        .links > a {
            color: #636b6f;
            padding: 0 25px;
            font-size: 13px;
            font-weight: 600;
            letter-spacing: .1rem;
            text-decoration: none;
            text-transform: uppercase;
        }
 
        .m-b-md {
            margin-bottom: 30px;
        }
    </style>
  </head>
  <body>
    <div class="flex-center position-ref full-height">
    @if (Route::has('login'))
      <div class="top-right links">
      @if (Auth::check())
        <a href="{{ url('/home') }}">HOME</a>
      @else
        <a href="{{ url('/login') }}">LOGIN</a>
        <a href="{{ url('/register') }}">REGISTER</a>
      @endif
      </div>
    @endif
      <div class="content">
        <div class="title m-b-md">
        Laravel
        </div>
        <div class="links">
          <a href="https://laravel.com/docs">Docs</a>
          <a href="https://laracasts.com">Laracasts</a>
          <a href="https://laravel-news.com">News</a>
          <a href="https://blog.laravel.com">Blog</a>
          <a href="https://nova.laravel.com">Nova</a>
          <a href="https://forge.laravel.com">Forge</a>
          <a href="https://vapor.laravel.com">Vapor</a>
          <a href="https://github.com/laravel/laravel">GitHub</a>
        </div>
      </div>
    </div>
  </body>
</html>
-----------------
@で始まる文は、Laravelに組み込まれているテンプレートエンジンを使って書かれたソ
ースコード。
Laravelでは、PHPをそのまま使ってWebページの表示を作成することもできるが、内蔵
するBladeテンプレートエンジンをつかうほうがはるかに多い。
viewsフォルダの中にテンプレートファイルが用意され、それをview関数が読み込んで
表示しているという仕組み。
==================================

＠ルート情報を追加する
/* routes/web.php */
Route::get('hello, function() {
  return <<<EOF
<html>
<body>
<h1>Hello</h1>
<p>This is sample page.</p>
</body>
</html>
==================================

＠HTMLを出力する
Route::getの第2引数にHTMLをリターンするクロージャを指定することで、HTMLがその
ままWebブラウザに送られる。
-----------------
Rouge::get('hoge', function() {
  return '<html><body>ねこ</body></html>';
});  
==================================

＠ヒアドキュメントを使う
$html = <<<EOF
<html>
<head>
<title>Hello</title>
<style>
body {
  font-size: 16pt; 
  color:#999;
}
h1 {
  font-size: 100pt;
  text-align: right;
  color: #eee;
  margin: -40px 0px -50px 0px;
}
</style>
</head>
<body>
  <h1>Hello</h1>
  <p>This is sample page.</p>
  <p>これは、サンプルでつくったページです。</p>
</body>
</html>
EOF;

Route::get('hello', function () use ($html) {
  return $html;
});
-----------------
このように、Route::getの働きとして「HTMLコードをreturnする関数を用意すれば、そ
のままWebページが表示される」という仕組み。
==================================

＠ルートパラメータの利用
Route::getでは、アクセスする際にパラメータを設定し、値を渡すことができる。
-----------------
Route::get('/○○/{パラメータ}', function($受け取る変数) {...});
-----------------
第1引数のアドレス部分に、{パラメータ}という形でパラメータを用意する。
{パラメータ}に指定された部分がパラメータとして取り出せるようになる。
第2引数のクロージャでは、パラメータの値を受け取る変数を引数として用意。
パラメータと同じ名前である必要はない。
パラメータは複数用意することができる。
----------------------------------
■パラメータを利用する。
-----------------
Route::get('hello/{msg}', function($msg) {
$html = <<<EOF
  <html>
  <head>
  <meta charset="utf8">
  <title>Hello</title>
  <style>
  body {
    font-size: 16pt; 
    color:#999;
  }
  h1 {
    font-size: 100pt;
    text-align: right;
    color: #eee;
    margin: -40px 0px -50px 0px;
  }
  </style>
  </head>
  <body>
    <h1>Hello</h1>
    <p>{$msg}</p>
    <p>これは、サンプルでつくったページです。</p>
  </body>
  </html>
EOF;
});
----------------------------------
■Route::getのパラメータについて
上記の例では
第1引数  "hello/{msg}"
第2引数  function($msg) { ... }
-----------------
これは、複数のパラメータでも同じ
Route::get('hello/{id}/{pass}', function($id, $pass) { ... }};
これで2つのパラメータ引数を利用できる。
==================================

＠必須パラメータと任意パラメータ
ルートをパラメタ指定した場合、基本的に必須パラメータであり、パラメータを指定せ
ずにアクセスするとエラーとなる。
パラメータをつけずともエラーにならないパラメータが「任意パラメータ」。
任意パラメータは、末尾に「?」をつけて宣言する。
第2引数の関数では、仮引数にデフォルト値を設定し、引数が渡されなくても処理でき
るようにしておく。
-----------------
Route::get('hello/{msg?}', function($msg='no message.') { ... }
==================================

2-2 コントローラの利用

＠MVCとコントローラ
ルーティングは、アクセスしたアドレスを元に処理を割り振る機能。
呼び出される「具体的な処理」を実装するのがコントローラ。
----------------------------------
■MVCアーキテクチャ
MVCは、「Model-View-Controller」の略。
アプリケーションの処理を、3つの要素として組み合わせていく考え方。
-----------------
モデル
データ処理全般を担当。
具体的にはデータベースアクセスに関する処理。
-----------------
ビュー
画面表示を担当。
テンプレートなど。
-----------------
コントローラ
全体の制御を担当。
必要に応じてモデルを使ってデータを取得したり、ビューを利用して画面表示を作成す
る。
-----------------
モデルやビューは特定の機能に特化したもので、コントローラは処理全体を制御する。
モデルやビューは不要であれば用意しなくてもよいが、コントローラは、ないと処理そ
のものが実行できない。
==================================

＠コントローラの作成
> php artisan make:controller HelloController
でHelloControllerクラスが作成される。
----------------------------------
■artisanのmake:controllerについて
artisanコマンドは以下の形式で実行する。
-----------------
php artisan コマンド
-----------------
コントローラの作成の場合は、
php artisan make:controller コントローラ名
これで、指定した名前でコントローラが作成される。
コントローラは、通常、○○Controllerという名前にする。
==================================

＠HelloController.php
コントローラは、app/Controllersフォルダに作成される。
-----------------
<?php
namespace App\Http\Controllers;

use Illuminate\Http\Request;

class HelloController extends Controller
{
  //
}
-----------------
これが、コントローラの基本ソースコード。
----------------------------------
■Controllers名前空間
コントローラは、クラスとして作成される。
このクラスは、App\Http\Controllers名前空間に配置される。
名前空間とは、クラスを階層的に整理するための仕組み。
フォルダを使って階層的にファイルを整理するのと同じ。
-----------------
ここでは、App\Http\Controllersという名前空間が使われている。
フォルダ構成に沿って名前空間が指定されている。
-----------------
namespace App\Http\Controllers
----------------------------------
■useによるクラスのインポート
use Illuminate\Http\Request;
-----------------
ここではIlluminate\Httpパッケージの「Request」を使える状態にしている。
まだ必要ないが、このあと多用されるので、デフォルトでuse文が追加されている。
----------------------------------
■クラスの定義
class HelloController extends Controller
{
  //
}
-----------------
コントローラクラスは、Controllerクラスを継承して作成する。
通常、名前は○○Controllerとする。
==================================

＠アクションを追加する
コントローラに用意される処理は「アクション」と呼ばれる。
これはメソッドの形。
アクションは、コントローラが行う処理で、複数用意できる。
-----------------
/* App/Http/Controllers/HelloController.php */
<?php
namespace App\Http\Controllers;

use Illuminate\Http\Request;

public class HelloContoller extends Controller
{
  public function index() 
  {
    return <<<EOF
<html>
<title>HelloIndex</title>
<head>
  <style>
  body {
    font-size: 16pt; 
    color:#999;
  }
  h1 {
    font-size: 100pt;
    text-align: right;
    color: #eee;
    margin: -40px 0px -50px 0px;
  }
  </style>
</head>
<body>
<h1>Index</h1>
<p>これは、Helloコントローラのindexアクションです。</p>
</body>
</html>
EOF;
  }  
}
-----------------
アクションメソッドでは、returnでHTMLのソースコードを返している。
これが、ブラウザへ返され、表示されることになる。
----------------------------------
■ルートの用意
アクションにルートを割り当てる必要がある。
-----------------
/* routes/web.php */
Route::get('hello', [HelloCotroller::class, 'index']);
-----------------
Ruoute::getを使ってルート情報を設定している。
==================================

＠ルートパラメータの利用
/* App/Http/Controllers/HelloController.php */
class HelloController extends Controller
{
  public function index($id='noname', $pass='unknown')
  {
    return <<<EOF
<html>
<title>Hello/Index</title>
<head>
  <style>
  body {
    font-size: 16pt; 
    color:#999;
  }
  h1 {
    font-size: 100pt;
    text-align: right;
    color: #eee;
    margin: -40px 0px -50px 0px;
  }
  </style>
</head>
<body>
<h1>Index</h1>
<p>これは、Helloコントローラのindexアクションです。</p>
<ul>
<li>ID: {$id}</li>
<li>PASS: {$pass}</li>
</ul>
</body>
</html>
EOF;
-----------------
/* routes/web.php */
Route::get('hello/{id?}/{pass?}', [HelloController::class, 'index']);
-----------------
■ルートパラメータの設定
{id?}、{pass?}と、任意パラメータとなっている。
----------------------------------
■アクションメソッドの設定
-----------------
public function index($id="noname", $pass="unknown") { ... }
-----------------
任意パラメータなので、デフォルト引数となっている。
==================================

＠複数のアクションの利用
コントローラには、複数のアクションを記述できる。
/* App/Http/Controllers/HelloController.php */
...
global $head, $style, $body, $end;
$head ='<html><head>';
$style= <<<EOF
 <style>
  body {
    font-size: 16pt; 
    color:#999;
  }
  h1 {
    font-size: 100pt;
    text-align: right;
    color: #eee;
    margin: -40px 0px -50px 0px;
  }
  </style>
EOF;
$body = '</head><body>';
$end = '</body></html>';

function tag($tag, $txt) 
{
  return "<{$tag}>" . $txt . "</{$tag}>" ;
}

class HelloController extends Controller
{
  public function index($id="noname", $pass="unknown") 
  {
    global $head, $style, $body, $end;
    $html = $head . tag('title', 'Hello/Index') . $style .
            $body
            . tag('h1', 'index') . tag('p', 'this is Index page')
            . '<a href="/hello/other">go to other page.</a>'
            . $end;
    return $html;   
  }
  
  public function other()
  {
    global $head, $style, $body, $end;
    $html = $head . tag('title', 'Hello/Other') . $style
                  . $body
                  . tag('h1', 'Other')
                  . tag('p', 'this is other page.')
                  . $end;
    return $html;
  }
}
-----------------
/* routes/web.php */
Route::get('hello', [HelloController::class, 'index']);
Route::get('hello/other', [HelloController::class, 'other']);
----------------------------------
■複数ページの対応
ページが複数になっても、基本的な実装は何ら変わらない。
注意すべきは、割り当てるアドレス。
----------------------------------
■アクションとアドレスの関係
アドレスとコントローラまたはアクションの関連は以下のように対応させるのが一般的
。
-----------------
http://アプリケーションのアドレス/コントローラ/アクション
-----------------
ルートの設定を独自のやり方で割り当てること自体は問題ないが、「割り当て方式が統
一されない」と問題。
どのようなやり方であれ、アプリケーション全体で首尾一貫させること。
----------------------------------

＠シングルアクションコントローラ
1つのコントローラに1つのアクションだけを用意する」という設計もある。
この場合、「シングルアクションコントローラ」としてクラスを作成する。
シングルアクションコントローラは、特別なクラスというわけではない。
一般的なアクションメソッドの代わりに「__invoke」というメソッドを使って実装する
。
----------------------------------
■シングルアクションコントローラの基本形
class コントローラ extends Controller
{
  public function __invoke() 
  {
    ....
  }
}
-----------------
__invoke以外は、アクションメソッドは用意しない。
メソッドは追加できるが、それらはアクションとしての利用はできない。
-----------------
シングルアクションコントローラとして作成されたコントローラは、ルート情報の設定
も少し変わってくる。
-----------------
Route::get('アドレス', 'コントローラ名');
-----------------
このようにコントローラ名だけを指定する。
アクションの指定はしない。
アドレスにアクセスると、コントローラのinvokeが実行される仕組み。
----------------------------------
■HelloControllerをシングルコントローラに
namespace App\Http\Controllers;

use Illuminate\Http\Request;

class HelloController extends Controller
{
  public function __invoke()
  {
    return <<<EOF
<DOCTYPE html>
<html>
<head>
<title>Hello</title>
<style>
  body {
    font-size: 16pt; 
    color:#999;
  }
  h1 {
    font-size: 100pt;
    text-align: right;
    color: #eee;
    margin: -40px 0px -50px 0px;
  }
</style>
</head>
<body>
<h1>Single Action</h1>
<p>これは、シングルアクションコントローラのアクションです。</p>
</body>
</html>
EOF;
  }
}
-----------------
/* routes/web.php */
Route:get('hello', HelloController::class);
-----------------
getの第2引数には、クラスしか記述しない。
これにより、__invokeメソッドが実行される。
----------------------------------
■invokeはPHPの基本機能
__invokeメソッドは、Laravelの機能ではなく、PHPのクラスに用意されている「マジッ
クメソッド」と呼ばれるメソッド。
マジックメソッドは、あらかじめ役割を与えられているメソッドで、一般に__で始まる
名前。
__invokeはそのクラスのインスタンスを関数的に実行するためのもので、インスタンス
に()を付けて関数をとして呼び出すと、インスタンス内の__invokeが実行される。
したがって、コントローラに限らず、一般的なクラスでも「インスタンスをそのまま関
数のように実行させたい」場合に利用される。
==================================

＠リクエストとレスポンス
ここまでのアクションメソッドは、引数も特に用意されて以内が実際のWebアクセスで
は、内部で非常に多くの情報を槍としている。
-----------------
リクエストとレスポンスの情報は、Laravelでも利用することができる。
これはIluminate\Http名前空間に用意されているRequestクラス、Responseクラスとし
て提供されている。
これらのオブジェクトには、リクエストまたはレスポンスに関する情報を保管するプロ
パティや、それを操作するメソッドが用意されている。
==================================
＠RequestとResponse
/* App/Http/Controllers/HelloController.php */
<?php
namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\Http\Response;

class HelloController extends Controller
{
  public function index(Request $request, Response $response)
  {

    $html = <<<EOF
<DOCTYPE html>
<html>
<hea    return <<<EOF
<html>
<title>HelloIndex</title>
<head>
  <style>
  body {
    font-size: 16pt; 
    color:#999;
  }
  h1 {
    font-size: 100pt;
    text-align: right;
    color: #eee;
    margin: -40px 0px -50px 0px;
  }
  </style>
</head>
<body>
<h1>Hello</h1>
<h3>Request</h3>
<pre>{$request}</pre>
<h3>Response</h3>
<pre>{$response}</pre>
</body>
</html>
EOF;
    $response->setContent($html);
    return $response;
  }
}
-----------------
/* routes/web.php */
Route::get('hello', [HelloController::class, 'index']);
-----------------
クライアントからヘッダー情報が、レスポンスからはキャッシュコントロールや日付な
どの情報が得られているのがわかる。
----------------------------------
■アクションメソッドの引数定義
まずは、RequestとResponseを利用するためuse文。
-----------------
use Illuminate\Http\Request;
use Illuminate\Http\Response;
-----------------
Requestはデフォルトで用意されているので、それにResponseを追加。
これらの利用はアクションメソッドで行う。
-----------------
public function index(Request $request, Response $response) { ... } 
-----------------
引数にRequestとResponseを追加するだけでインスタンスが用意され、利用可能となる
。
----------------------------------
■Requestの主なメソッド
-----------------
$request->url()
urlは、アクションしたURLを返す。
ただし、クエリ文字列は省略される。
-----------------
$request->fullUrl()
fullUrlは完全なアドレスを返す（クエリ文字列も含む）。
-----------------
$request->path()
pathは、ドメイン下のぱす部分だけを返す。
----------------------------------
■Responseの主なメソッド
-----------------
$response->status()
アクセスに関するステータスコードを返す。
正常なら200。
-----------------
$response->content();
$response->setContent(値);
コンテンツの取得・設定を行うもの。
contentはコンテンツを取得
setContentは引数の値にコンテンツを変更する。
----------------------------------
■サービスとDI
Laravelでは、アクセスメソッドの引数にRequestやResponseを追加するだけで、それら
が利用できるようになる。
これは「サービス」と「サービスコンテナ」の機能。
Laravelでは各種の機能が「サービス」と呼ばれる形のプログラムとして用意されてい
る。
このサービスは、「サービスコンテナ」と呼ばれるものに組み込まれ、管理されている
。
-----------------
アクセスメソッドに引数を追加すると、サービスコンテナによって、対応するクラスの
インスタンスがその引数に渡され、利用できるようになる。
この機能は「メソッドインジェクション」と呼ばれる。
-----------------
このサービスコンテナのように、必要に応じて自動的に機能を組み込む仕組みは、Lara
vel以外でも多用されている。
一般に「DI（Dependency Injection）」と呼ばれ、関連する機能を自動的に組み込む働
きを実現する。
DI技術により、メソッドに引数を追加するだけで、自動的にサービスが組み込まれる、
メソッドインジェクションが実現される。
==================================

chaper 3 ビューとテンプレート

＠PHPテンプレートの利用
Laravelでは、PHPスクリプトファイルで「テンプレート」を作成し、表示することがで
きる。
またBladeという独自の高機能なテンプレート機能も持っている。
==================================

＠ビューについて
コントローラで、標示内容をテキストとして変数に持たせるようなやり方では、複雑な
表現はできない。
本格的なウェブページを作るためには、HTMLを使ってそのまま表示内容を記述できるよ
うな仕組みが必要。
こうした用途のために用意されているのが「テンプレート」。
テンプレートは、Laravelの「ビュー（view）」を担当する重要な部品。
-----------------
Laravelでは、Model-View-Controller（MVC）アーキテクチャに基づいて設計されてい
る。
ビューは、画面表示を担当、画面の表示に関する部分を簡単にわかりやすい形で作れる
ようにしている。
そのために採用されているのがテンプレート。
-----------------
テンプレートは、画面表示のベースとなるもの。
あるアドレスにアクセスすると、コントローラはそのアドレスで使われるテンプレート
を読み込んで表示する。
ただし、読み込まれたHTMLコードがそのまま表示されるわけではない。
==================================

＠レンダリングの考え方
テンプレートには、あらかじめ変数や処理などが記述されている。
Laravelでは、テンプレートを読み込んだ後、その中に必要な情報をはめ込むなどして
、実際の表示を生成することができる。
この作業を「レンダリング」という。
-----------------
レンダリングにより、テンプレート内の処理は変数などが実行され、処理結果や変数の
値が、実際の表示として組み込まれていく。
レンダリングにより、コントローラで用意しておいた値や変数などを組み込んだHTMLソ
ースコードが生成される。
-----------------
レンダリングは「テンプレートエンジン」によって行われる。
テンプレートエンジンには、色々なものがある。
-----------------
Laravelでは、大きく2つのテンプレートが用いられる。
1つがPHPソースコードをそのままテンプレートとして使う方法。
もう1つが「Blade」と呼ばれるテンプレートエンジンを使う方法。
==================================

＠PHPテンプレートを作る
テンプレートはresources/viewsフォルダに配置する。
テンプレートは、各コントローラごとにフォルダを用意し、その中にコントローラで使
うテンプレートをまとめておくのが一般的。
-----------------
/* resources/views/hello/index.php */
<html>
<head>
<title>Hello/Index</title>
<style>
body {
  font-size: 16pt;
  color: #999;
}
h1 {
  font-size: 100pt;
  text-align: right;
  color: #f6f6f6;
  margin: -50px 0 -100px 0px;
}
</style>
</head>
<body>
<h1>Index</h1>
<p>This is a sample page with php-templage.</p>
</body>
</html>
==================================

＠ルートの設定でテンプレートを表示する。
/* routes/web.php */
Route::get('hello', function() {
  return view('hello.index');
});
-----------------
コントローラは使っていない。
ルート情報の設定の部分で、直接テンプレートを使っている。
----------------------------------
■viewメソッドについて
ここでは第2引数のクロージャ内でviewメソッドを使っている。
viewは、引数にテンプレート名を指定すると、そのテンプレートを読み込んで返す。
viewは以下のような形で呼び出す。
-----------------
view('フォルダ名.ファイル名')
-----------------
テンプレートは、viewsフォルダから検索される。
hello.indexとすると、views/hello/inderx.phpを指定したことになる。
「どのフォルダの何というファイルか」をきちんと指定しなければならない。
----------------------------------
■viewとResponse
viewメソッドの戻り値をreturnすると、そのままテンプレートの内容が表示される。
viewが返すのは、Responseインスタンス。
このResponseには指定したテンプレートのレンダリング結果がコンテンツとして設定さ
れている。
結果としては「viewの戻り値をそのまま返せばテンプレートの内容が表示される」が、
「viewによりテンプレートのソースコードがそのまま返されるわけではない。
==================================

＠コントローラでテンプレートを使う
/* App/Http/Controllers/HelloController.php */
public function index()
{
  return view('hello.index');
}
-----------------
やっていることは、クロージャを使った方法と同じ。
Route::getでviewするか、Route::getで呼び出されたアクションメソッド内でビューす
るかの違いだけ。
==================================

＠値をテンプレートに渡す
/* resources/views/hello/index.php */
<body>
<h1>Index</h1>
<p><?php echo $msg; ?></p>
<p><?php echo date("Y年n月j日"); ?></p>
</body>
-----------------
<?php ?>タグを使ってPHPのスクリプトを記述すれば、そのままスクリプトを実行でき
る。
そのためには、コントローラ側からテンプレート側へ、必要な変数などの値を渡さなけ
ればならない。
-----------------
/* App/Http/Controllers/HelloController.php */
public function index()
{
  $data = [
    'msg'=>'これはコントローラから渡されたメッセージです。'
  ];
  return view('hello.index', $data);
}
----------------------------------
■テンプレートへの値の更け渡し
ここではindexアクションのviewメソッドで、必要な値をテンプレート側に渡している
。
-----------------
return view(テンプレート, 配列);
-----------------
第2引数に渡される配列に格納した値が、そのままテンプレート側に変数として渡され
る。
このように、viewのダ2引数では、テンプレート側で使う変数名をキーに指定して値を
設定する。
配列なので、いくつでも値を用意して渡すことが可能。
==================================

＠ルートパラメータをテンプレートに渡す
アクセス時のアドレスに記述しておいた値が、そのままテンプレートに表示されるよう
にするには、2つの部分に分けて考える。
1つはルートパラメータを受け取る部分。
もう2つ目は値をテンプレートに書き出す部分。
-----------------
/* resources/views/hello/index.php */
<body>
<h1>Index</h1>
<p><?php echo $msg; ?></p>
<p>ID=<?php echo $id; ?></p>
</body>
-----------------
$idという変数を追加して表示させている。
----------------------------------
■アクションの修正
/* App/Http/Controllers/HelloController.php */
public function index($id='zero')
{
  $data = [
    'msg'=>'これはコントローラから渡されたメッセージです。',
    'id=>$id,
  ];
  return view('hello.index', $data);
}
-----------------
これにより、ルートパラメタである引数$idの値が、テンプレートで$idという変数で参
照できるようになる。
----------------------------------
■ルート情報の修正
/* routes/web.php */
Route::get('hello/{id?}', [HelloController::class, 'index']);
-----------------
{id?}の値が、コントローラのindexアクションメソッドに引数として渡される。
==================================

＠クエリ文字列の利用
アクセスするアドレスの情報を利用して値を渡す方法はもう1つある。
「クエリ文字列」を使う方法。
クエリ文字列は、ルートパラメタとは受け取り方が違う。
-----------------
/* App/Http/Controllers/HelloController.php */
public function index(Request $req)
{
  $data = [
    'msg'=>'これはコントローラから渡されたメッセージです。',
    'id'=>$req->id
  }
  return view('hello.index', $data);
}
-----------------
引数にRequestインスタンスを渡すようにしている。
そしてテンプレートに渡すidの値は、$req->idというふうに取り出している。
このidがクエリ文字列で渡される値。
-----------------
ルート情報を修正する。
-----------------
/* routes/web.php */
Route::get('hello', [HelloContgroller::class, 'index']);
-----------------
アドレスからルートパラメタが消えている。
次のようにアクセスする。
http://localhost:8000/hello?id=query_string_sample
-----------------
$id=query_string_sampleというふうにして、このquery_string_sampleが、$req->idと
して取り出されている。
このように、クエリ文字列を使って渡された値は「$req->キー名」という形で取り出す
ことができる。
ルートパラメタと異なり、ルート情報には何ら特別な記述は要らない。
アクションでRequest引数を用意するだけでよい。
==================================

3-2 Bladeテンプレートを使う

＠Bladeを使う
PHPスクリプトファイルをそのままテンプレートとして使うのは、記述が煩雑になるき
らいがある。
ちょっとした表示でも<?php echo xxx; ?>としなければならない。
また、PHPタグが<>を使っており、一般的なHTMLタグと同じ形式になっているため、HTM
L作成ツールなどでは、タグ構造が崩れたりする。
また、ページを分割してまとめてレイアウトする機能もない。
HTMLとPHPで手作業でレイアウトするしかない。
-----------------
Laravelに独自に用意されているBladeテンプレートエンジンは、非常に効率的なレイア
ウトを作成していくための機能を持っている。
テンプレートを継承してあらたなテンプレートを定義したり、レイアウトの一部をセク
ションとしてはめ込むなどして、レイアウトを作っていくことができる。
----------------------------------
■テンプレートを作る
Bladeテンプレートも、PHPテンプレートと同様、resources/viewsフォルダに配置する
。
Bladeテンプレートファイルは、xx.blade.phpという名前でファイルを用意する。
-----------------
/* resources/views/hello/index.blade.php */
<html>
<head>
<title>Hello/Index</title>
<style>
body {
  font-size: 16pt;
  color: #999;
}
h1 {
  font-size: 100pt;
  text-align: right;
  color: #f6f6f6;
  margin: -50px 0 -100px 0px;
}
</style>
</head>
<body>
<h1>Blade/Index</h1>
<p>{{ $msg }}</p>
</body>
</html>
-----------------
基本的な部分は、普通のHTMLと同じ。
<p>タグの部分の{{ $msg }}は、変数$msgを埋め込んだもの。
Bladeでは、{{ $変数 }}というようにして、変数をテンプレート内に埋め込むことがで
きる。
----------------------------------
■アクションの修正
/* App/Http/Controllers/HelloController.php */
public function index()
{
  $data = [
    'msg'=>'これはBladeを利用したサンプルです。',
  ];
  return view('hello.index', $data);
}
-----------------
/helloにアクセスると、index.blade.phpを使って画面が表示される。
----------------------------------
■index.phpとindex.blade.php、どちらを使う？
Laravelでは、Bladeテンプレートがあると、それが優先して読み込まれる。
テンプレート名を「index」と指定してあると、index.phpではなくindex.blade.phpが
使われる。
index.blade.phpがない場合は、index.phpが使われる。
==================================

＠フォームを利用する
/* resources/views/hello/index.blade.php */
<body>
<h1>Blade/Index</h1>
<p>{{ $msg }}</p>
<form method="POST" action="/hello">
  @csrf
  <input type="text" name="msg">
  <input type="submit">
</form>
</body>
-----------------
@csrfは、Bladeディレクティブと呼ばれ、テンプレートに決まったコードを生成して書
き出す働きをする。
==================================

＠CSRF対策について
@csrfは、CSRF対策のために用意されたBladeディレクティブ。
CSRFは、「Cross Site Request Forgery」と呼ばれる、Webサイト攻撃の1つ。
スクリプト等を使い、外部からフォームを送信するもので、フォームに大量のコンテン
ツを送り付けたりするのに用いられる。
-----------------
@csrfは、トークンと呼ばれるランダムな文字列を非表示フィールドとして追加する。
そして、このトークンの値が正しいフォームだけを受け付けるようにする。
-----------------
Laravelでは、CSRF対策がなされていないフォームの送信は、例外が発生して受け付け
られないようになっている。
したがって、フォームを利用する際は、必ず@csrfをフォーム内に用意しておく必要が
ある。
==================================

＠アクションの用意
今回は、/helloにアクセスしたときの表示と、フォームを送信したときの処理の2つの
アクションが必要となる。
-----------------
/* App/Http/Controllers/HelloController.php */
class HelloController extends Controller
{
  public function index()
  {
    $data = [
      'msg'=>'お名前を入力してください。',
    ];
    return view('hello.index', $data);
  }
  public function post(Request $req)
  {
    $msg = $req->msg;
    $data = [
      'msg'=>'こんにちは、' . $msg . 'さん!',
    ];
    return view('hello.index', $data);
  }
}
-----------------
indexアクションは、/helloにアクセスした際の処理。
postメソッドが、/helloにPOST送信された時の処理。
Requestインスタンスを引数とし、以下のようにフォームの内容を取り出している。
-----------------
$msg = $req->msg;
-----------------
name="msg"のフィールドの値は、このように$req->msgで取り出せる。
フォームで送信された値は、すべてnameのプロパティとして取り出せるようになってい
る。
==================================

＠POSTのルート設定
/* routes/web.php */
Route::get('hello', [HelloController::class, 'index',]);
Route::post('hello, [HelloController::class, 'post',]);
-----------------
POST送信は、Route::postメソッドで設定する。
メソッド名が違うだけで、使い方はRoute::getと同じ。
割り当てるアドレスと、呼び出すアクションをそれぞれ引数に指定する。
-----------------
ここでは/helloにHelloControllerクラスのpostメソッドを割り当てている。
同じアドレスでも、GETとPOSTというようにアクションするメソッドの種類が違えば、
両方ともに使うことができる。
----------------------------------
■ChromeにおけるTokenMismatchException問題
@csrfをつければCSRにひっからずにフォーム送信ができるはず、だが、実際に送信する
と、TokenMismatchException（CSRF対策のトークンの値が合わないエラー）が出ること
がある。
開発中は、CSRF対策の機能をOFFにしておく、ということもできる。
CSRF対策を行っているのは、VerifyCsrfTokenというミドルウェアで、これを使わない
ように設定すればよい。
==================================

3-3 Bladeの構文

＠値の表示
まずは値を埋め込む{{}}から。
-----------------
{{ 値・変数・式・関数など }}
-----------------
このように{{と}}の間に、文を書くことで、その文が返す値をその場に書き出す。
値として扱えるものは、関数でもメソッドでも指定できる。
-----------------
{{ }}の出力は、基本的にHTMLエスケープ処理される。
HTMLタグなどをテキストとして設定した場合も、すべてエスケープ処理されるため、タ
グはテキストとして表示され、HTMLタグとしては機能しない。
エスケープしょりされてほしくない場合は幾何のようにする。
-----------------
{!! 値・変数・式・関数など !!}
-----------------
{!!と!!}の間に値を設定する。
これでエスケープ処理されなくなり、HTMLタグなどはそのままタグとして機能する。
==================================
＠ifディレクティブ
Bladeには、ディレクティブという機能がある。
これは、言語における構文のような役割を果たす。
条件分岐（if）に相当するディレクティブが@if。
----------------------------------
■条件がtrueのときに表示をする
@if ( 条件 )
...出力内容...
@endif
----------------------------------
■条件によって異なる表示をする
@if (条件)
...出力内容...
@else
...出力内容...
@endif
----------------------------------
■複数の条件を設定する
@if (条件)
...出力内容...
@elseif (条件)
...出力内容...
@else
...出力内容...
@endif
----------------------------------
ディレクティブは、基本的に「@ディレクティブ名」という形で記述する。
@ifは、その後に条件を設定する。
trueなら、それ以降@endifまでの部分を表示する。
-----------------
@ifには、@elseifと@elseディレクティブが用意されている。
@elseifは、いくつでもつづけて記述できる。
-----------------
基本的にPHPのif文と同じ働きをするが、ディレクトリの場合は、何かを実行するので
はなく「表示する」。
「条件がtrueならこれを表示する、falseならこれを表示する」というように条件に応
じて、表示する内容を制御するのが@if。
----------------------------------
■@ifを利用する
/* resources/views/hello/index.blade.php */
<body>
<h1>Blade/Index</h1>
@if ($msg != '')
<p>こんにちは、{{$msg}}さん。</p>
@else
<p>何か書いてください。</p>
@endif
<form method="POST" action="/hello">
  @csrf
  <input type="text" name="msg">
  <input type="submit">
</form>
</body>
-----------------
$msg!=''がtrueなら$msgを使ったメッセージを表示している。
falseなら、「何か書いてください。」と表示させている。
==================================

＠特殊なディレクティブ
分岐処理を行うディレクティブはいくつか用意されている。
いずれもオプションとして@elseを追加できる。
----------------------------------
■条件が非成立のときに表示
@unless (条件)
...表示内容...
@endulness
-----------------
@ifと逆の働きをする。
falseで表示、trueで非表示。
@elseを用意した場合は、条件がtrueの時に表示される。
----------------------------------
■変数が空の場合に表示
@empty (変数)
...表示内容...
@endempty
-----------------
(変数)に指定した、変数が空の場合に表示を行う。
@elseは、変数が空でなく、値が設定されている場合に表示される。
----------------------------------
■変数が定義済みの場合に表示
@isset (変数)
...表示内容...
@endisset
-----------------
@emptyと似ているが、@issetは、変数そのものが定義されているかを確認する。
変数が定義され、nullｄない場合に表示をを行う。
@elseを用意することで、変数が未定義またはnullだった場合の表示を用意できる。
----------------------------------
■@issetで変数定義をチェックする
/* resources/views/hello/index.blade.php */
<body>
<h1>Blade/Index</h1>
@isset ($msg)
<p>こんにちは、{{ $msg }}さん。</p>
@else
<p>何か書いてください。</p>
@endisset
<form method="POST" action="/hello">
...
-----------------
/* App/Http/Controllers/HelloController.php */
class HelloController extends Controller
{
  public function index()
  {
    return view('hello.index');
  }
  public function post(Request $req)
  {
    $data = [
      'msg'=>$req->msg,
    ];
   return view('hello.index', $data);
  }
}
-----------------
ここではindexアクションで値をテンプレートに渡していないので、当然$msgは未定義
となり、@issset($msg)はfalseとなる。
このように、「GET時には値がない」「POSTされると値が渡される」等処理を@issetで
分岐できる。
これによりコードがシンプルになる。
==================================

＠繰り返しのディレクティブ
■for文に相当するもの
-----------------
@for (初期化; 条件; 後処理)
...繰り返す表示...
@endfor
----------------------------------
■foreach文に相当するもの
@foreach ($配列 as $変数)
...繰り返す表示...
@endforeach
----------------------------------
■foreach-else構文に相当するもの
@forelse ($配列 as $変数)
...繰り返す表示...
@empty
...$変数が空のときの表示...
@endforelse
-----------------
これは、foreach構文にelseを追加した場合の処理に相当。
()の配列から順に値を取り出していくのは@foreachと同じだが、値をすべて取り出し終
えて、取り出せなくなったとき、@emptyにある処理を実行して繰り返しを終える。
----------------------------------
■whileに相当するもの
@while (条件)
...繰り返す表示...
@endwhile
-----------------
@whileでは、実行時に条件で使っている変数などの値が変化しなければ、無限ループと
なってしまうため、ディレクティブ内で何らかの処理を実行する必要がある。
これには@phpディレクティブが必要となる。
----------------------------------
■繰り返しディレクティブを利用する
/* resources/views/hello/index.blade.php
<body>
<h1>Blade/Index</h1>
<p>&#64;foreachディレクティブの例</p>
<ol>
@foreach ($data as $item)
<li>{{ $item }}</li>
@endforeach
</ol>
</body>
-----------------
@foreachディレクティブに($data as $item)という形で繰り返しの設定をしている。
これにより、$dataから順に値を取り出して$itemに代入する、という繰り返しが実行さ
れる。
コントローラ側では、$dataに配列を渡すようにすればよい。
-----------------
/* App/Http/Controllers/HelloController.php */
public function index()
{
  $data = ['one', 'two', 'three', 'four', 'five',];
  return view('hello.index', ['data'=>$data,]);
}
==================================

＠@breakと@continue
繰り返しディレクティブでも、breakやcontineに相当するものが用意されている。
----------------------------------
■@break
PHPのbreakに相当。
これが出力されると、その時点での繰り返しのディレクティブが中断される。
----------------------------------
■@continue
PHPのcontinueに相当。
これより後は表示せず、すぐに次の繰り返しに進む。
----------------------------------
/* resources/views/hello/index.blade.php */
<body>
<h1>Blade/Index</h1>
<p>&#064;forディレクティブの例</p>
<ol>
@for ($i = 1; $i < 100; $i++)
@if ($i % 2 == 1)
  @continue
@elseif ($i <= 10)
<li>No, {{ $i }}</li>
@else
  @break
@endif
@endfor
==================================

＠$loopによるループ変数
繰り返しディレクティブには、$loopという特別な変数が用意されている。
ループ変数と呼ばれるもので、繰り返しに関する情報などを得ることができる。
繰り返しに関するプロパティがいろいろと用意されている。
-----------------
$loop->index
現在のインデクス（ゼロ始まり）
-----------------
$loop->iteration
現在の繰り返し数（1から開始）
-----------------
$loop->remaining
あと何回繰り返すか（残り回数）
-----------------
$loop->count
繰り返しで使っている配列の要素数
-----------------
$loop->first
最初の繰り返しかどうか（最初ならtrue）
-----------------
$loop->last
最後の繰り返しかどうか（最後ならtrue）
-----------------
$loop->depth
繰り返しのネスト数
-----------------
$loop->parent
ネストしている場合、親の繰り返しのループ変数を示す。
-----------------
/* resources/views/hello/index.blade.php */
<body>
<h1>Blade/Index</h1>
<p>&#64;forディレクティブの例</p>
@foreach ($data as $item)
@if ($loop->first)
<p>※データ一覧</p>
<ul>
@endif
<li>No.{{ $loop->iteration }}. {{ $item }}</li>
@if ($loop->last)
</ul>
<p>---ここまで</p>
@endif
@endforeach
</body>
-----------------
このように、$loopを利用することで、繰り返し状態などに応じた表示を簡単に作成し
ていくことができる。
==================================

＠@phpディレクティブについて
ディレクティブは、PHPそのものではない。
複雑な処理のため、PHPのスクリプトを実行する必要がある場合もある。
-----------------
PHPのスクリプトは、@phpディレクティブを使って記述することができる。
-----------------
@php
...PHPのスクリプト...
@endphp
-----------------
@phpを使えば、Bladeテンプレート内で直接スクリプトを実行し、必要な処理を行うこ
とができる。
-----------------
/* resources/views/hello/index.blade.php */
<body>
<h1>Blade/Index</h1>
<p>&#64;whileディレクティブの例</p>
<ol>
@php
$counter = 0;
@endphp
@while ($counter < count($data))
<li>{{ $data[$counter] }}</li>
@php
$counter++;
@endphp
@endwhile
</ol>
</body>
-----------------
ただし、テンプレートは、「処理と表示を切り離す」ために用意されたもの。
処理はコントローラ（アクション）、テンプレートで表示、それが基本。
複雑なスクリプトを@phpで記述する必要が生じたら、アプローチ自体が間違ってないか
、考えること。
テンプレートに用意するスクリプト（@php）は必要最小限にすること。
==================================

3-4 レイアウトの作成

＠レイアウトの定義と継承
多くのページがあるサイトでは、全体の統一感を持たせるため、共通したデザインでペ
ージが表示されるようにするのが一般的。
そのため、サイト全体で共通するベースとなるレイアウトを用意し、それを元に各ペー
ジのデザインを行うようにする。
こうしたサイト全体を統一したデザインでレイアウトするために、Bladeには強力な機
能が用意されている。
それが「継承」と「セクション」
----------------------------------
■継承とは？
Bladeの継承の、クラスの継承と考え方は同じ。
既にあるテンプレートのレイアウトを継承して新しいテンプレートを作成する。
継承元のテンプレートに用意されている表示は、すべて新たに継承して作られたテンプ
レートでそのまま表示される。
新しいテンプレートでは、継承元にはない要素を用意するだけ。
----------------------------------
■セクションとは？
継承でページをデザインするとき、ページ内の要素として活用されるのが「セクション
」。
セクションは、レイアウト内に用意される区画。
レイアウト用テンプレートでは、ページ内にセクションの区画を用意しておき、継承し
て作られた新しいテンプレートで、そのセクションの内容を用意する。
これにより、指定の内容がセクションに組み込まれ、レイアウトが完成する。
----------------------------------
この継承とセクションにより、ベースとなるレイアウトから同じレイアウトのページを
いくつも作っていくことが可能となる。
==================================

＠@sectionと@yield
セクションの利用のため、Bladeでは2つのディレクティブが用意されている。
そらが@sectionと@yield。
----------------------------------
■@sectionについて
レイアウトで、さまざまに区画を定義するために用いられるのが、@section。
@sectionは、ページに表示されるコンテンツの区画を定義する。
-----------------
@section(名前)
...表示内容
@endsection
-----------------
これで、指定したセクションが表示される。
このセクションは、同じ名前の@yieldにはめ込まれ、表示される。
また、@sectionは、継承したテンプレートで@sectionによって上書きすることもできる
。
----------------------------------
@yieldについて
@yieldは、セクションの内容をはめ込んで表示するためのもの。
-----------------
@yield(名前)
-----------------
@yieldで指定した名前のセクションがあると、そのセクションが@yieldのところにはめ
込まれる。
@yieldは、配置場所を示すものなので、@yieldendのようなものはない。
具体的なコンテンツを用意する必要はないので。
==================================

＠ベースレイアウトを作成する
resources/views内にlayoutsフォルダを作成する。
レイアウトのテンプレートは、通常このlayoutsフォルダに配置する。
以下、ベースとなるレイアウト用のファイル。
-----------------
/* resources/views/layouts/helloapp.blade.php */
<html>
<title>@yield('title')</title>
<style>
body {
  font-size: 16pt;
  color: #999;
  margin: 5px;
}
h1 {
  font-size:50pt;
  text-align: right;
  color: #f6f6f6;
}
ul {
  font-size: 12pt;
}
hr {
  margin: 25px 100px;
  border-top: 1px dashed #ddd;
}
.menutitle {
  font-size: 14pt;
  font-weight: bold;
  margin: 0px;
}
.content {
  margin: 10px;
}
.footer {
  text-align: right;
  font-size: 10pt;
  margin: 10px;
  border-bottom: solid 1px #ccc;
  color: #cc;
}
</style>
</head>
<body>
<h1>@yield('title')</h1>
@section('menubar')
<h2 class="menutitle">※メニュー</h2>
<ul>
<li>@show</li>
<ul>
<hr size="1">
<div class="content">
@yield('content')
</div>
<div class="footer">
@yield('footer')
</div>
</body>
</html>
-----------------
ディレクティブを簡単にまとめると。
-----------------
<title>@yield('title')</title>
<h1>@yield('title')</h1>
-----------------
ここにtitleのコンテンツを設定する。
-----------------
@section('menubar')
-----------------
これは、メニュー表示の区画。
セクションは区画を定義するものだが、一番土台となるレイアウトで@sectionを用意す
る場合は、@showディレクティブでセクションの終わりを指定する。
-----------------
@yield('content')
@yield('footer')
-----------------
これらは、それぞれコンテンツとフッターをはめ込むために配置されている。
継承したレイアウトで、これらの名前で@sectionを用意しておけば、そのセクションの
レイアウトが@yieldによってはめ込まれる。
==================================

＠継承レイアウトの作成
レイアウト用のテンプレートを継承して、実際のWebページのテンプレートを作成する
。
-----------------
/* resources/views/hello/index.blade.php */
@extends('layoutes.helloapp')
@section('title', 'Index')
@section('menubar')
  @parent
  インデクスページ
@endsection

@section('content')
  <p>ここが本文のコンテンツです。</p>
  <p>必要なだけ記述できます。</p>
@endsection

@section('footer')
copyright 2020 tuyano.
@endsecton
----------------------------------
■@extendsについて
まず最初にレイアウトの継承設定。
@extendsを使う。
-----------------
@extends('layouts.helloapp')
-----------------
これにより、layouts/helloapp.blade.phpというレイアウトテンプレートをロードし、
親レイアウトとして継承している。
これがないと、レイアウトの継承そのものが機能しなくなる。
----------------------------------
■@sectionの書き方
@sectionには2通りの書き方がある。
1つは、タイトルの表示に使った方法。
-----------------
@section('title', 'Index')
-----------------
単純にテキストや数字などをセクションに表示させるだけなら、@sectionの引数内に、
セクション名と、表示する値を設定する。
-----------------
もう1つの書き方は、@endsectionを併用した書き方。
-----------------
@section('menubar')
  @parent
  インデクスページ
@endsection
-----------------
@sectionから@endsectionまでの部分がセクションの内容となる。
親レイアウトに@yield('menubar')があれば、そこにはめ込まれて表示される。
-----------------
ただし、今回の親レイアウトには、menubarという@yieldはなく、@sectionがある。
この場合、@sectionは上書きして置き換わる。
-----------------
@parentディレクティブは、親レイアウトのセクションを示す。
親の@sectionに子の@sectionを指定する場合、親の@section部分をこのセクションが上
書きする。
その際、親にあるセクションも表示したいこともある。
このような場合、@parentディレクティブで親のセクションをはめ込んで表示させるこ
とができる。
-----------------
その他、@section('content)や@section('footer')などは、親レイアウトの@yieldで場
所を指定しているだけなので、その部分にセクションがはめ込まれる。
----------------------------------
■表示を確認する
。。。
==================================

＠コンポーネントについて
継承したレイアウトでは、継承した、親レイアウトの必要な部分に子側のセクションを
はめ込んで表示を完成させた。
このやり方は、全体を一式揃えて作成するには大変便利。
が、時には、「一部を切り離して作成し、それを組み込みたい」場合もある。
例えば、タイトルやフッターの表示などは、独立した部品として用意しておければ便利
。
各レイアウトから、タイトルやフッタの部分を切り離すことで、純粋にそのページだけ
のコンテンツに集中できる。
また、必要に応じて、その部品だけを修正すれば、サイト全体の表示を更新できる。
-----------------
このような場合に用いられるのが「コンポーネント」。
コンポーネントは、1つのテンプレートとして独立して用意されるレイアウト部品。
コンポーネントは、テンプレートから読み込まれ、必要な場所に組み込まれる。
----------------------------------
■@componentディレクティブ
コンポーネントは普通のテンプレートとして内容を作成する。
書き方は普通のテンプレートと同じ。
作成されたコンポーネントは、@componentディレクティブを使って表示場所を設定する
。
----------------------------------
■コンポーネントの組み込み
-----------------
@component(名前)
...コンポーネントの表示内容...
@endcomponent
-----------------
コンポーネントの名前は、viewsフォルダにあるファイル名で指定される。
例えばcomponents/ok.blade.phpなら「components.ok」。
==================================

＠コンポーネントを作成する
/* resources/views/components/message.blade.php */
<style>
.message {
  border: double 4px #ccc;
  margin: 10px;
  padding: 10px;
  background-color: #fafafa;
}
.msg_title {
  margin: 10px 20px;
  color:#999;
  font-size: 16pt;
  font-weight: bold;
}
.msg_content {
  margin: 10px 20px;
  color: #aaa;
  font-size: 12pt;
}
</style>
<div class="message">
  <p class="msg_title">{{ $msg_title }}</p>
  <p class="msg_content">{{ $msg_content }}</p>
</div>
-----------------
$msg_titleと$msg_content変数を表示するテンプレート。
----------------------------------
■コンポーネントを組み込む
-----------------
/* resources/views/hello/index.blade.php */
@section('content')
  <p>ここが本文のコンテンツです。</p>
  <p>必要なだけ記述できます。</p>
  
  @component('components.message')
    @slot('msg_title')
    CAUTION!
    @endslot
    
    @slot('msg_conetnt')
    これはメッセージの表示です。
    @endslot
  @endcomponent

@endsection
-----------------
このように、コンポーネントを組み込むことで、さまざまな表示をレイアウトの中に追
加できる。
----------------------------------
■スロットについて
ここでは、message.blade.phpの中に{{ $msg_title }}と{{ $msg_content }}という変
数を配置。
コンポーネントを利用する際は、これらの変数に必要な値を渡さなくてはならない。
それを行うのが「スロット」。
スロットは、{{ }}で指定された変数に値を設定するもの。
-----------------
@slot(名前)
...設定する内容...
@endslot
-----------------
@component('components.message')として、components/message.blade.phpをコンポー
ネントとして組み込むことを指定している。
そして、@component内に、@slot('msg_title')、@slot('msg_conetnt')とすることで、
これらのスロットの内容が、コンポーネントの$msg_title、$msg_content変数にはめ込
まれて表示される。
-----------------
コンポーネントを使い、ページに表示されるさまざまな部品を用意しておけば、それら
を組み合わせてページをデザインすることができるようになる。
すべて統一されたデザインとして表示される。
==================================

＠サブビューについて
コンポーネントは使い勝手の良い部品だが、ページフッターやサイドバーなど定型のコ
ンテンツは、もっと単純に「用意したテンプレートをただはめ込んで表示できればよい
」ものもある。
こうしたものは、テンプレートを読み込んでそのままテンプレート内にはめ込むことが
できる。
こうした「あるビューから別のビューを読み込んではめ込んだもの」をサブビューとい
う。
-----------------
サブビューは、専用のテンプレートがあるわけではない。
普通のテンプレートとして作成し、それをそのまま読み込んで表示するだけのシンプル
な仕組み。
-----------------
スロットのようなものは、サブビューでは使えない。
ただし、コントローラから渡された変数などは、そのままサブビューのテンプレート内
でも使うことができる。
また、サブビューを読み込む際に変数を渡すこともできる。
-----------------
@include(テンプレート名, [...値の指定...])
-----------------
第1引数には、読み込むテンプレートファイルを指定する。
単にテンプレートを表示するなら、第1引数だけでよい。
何らかの値をサブビューのテンプレートに渡したい場合は、第2引数に連想配列にまと
めた値を用意しておく。
----------------------------------
■サブビューで読み込む
/* resources/views/heloo/index.blade.php */
@section('content')
  <p>ここが本文のコンテンツです。</p>
  <p>必要なだけ記述できます。</p>
  @include('componentsw.message', 
           ['msg_title'=>'OK', 'msg_content'=>'サブビューです。'])
@endsection
-----------------
ここでは、@includeの第2引数にmsg_titleとmsg_contentの値を配列として渡し、必要
な値をサブビュー側に渡して表示させることができる。
==================================

＠@eachによるコレクションビュー
表示の一部を切り離して作成する、ということを考えたとき、利用頻度が高いのが「繰
り返しの表示」。
データを繰り返してディレクティブなどで奉持するとき、表示する各項目のレイアウト
を切り離して作成できれば便利。
-----------------
テーブルの表示、リストの表示、通常のテキストコンテンツの表示などあらかじめ用意
しておいたデータを繰り返し表示させることはよくある。
こうした場合に便利なのが@eachディレクティブ。
-----------------
@eachディレクティブは、あらかじめ用意されていた配列やコレクションから順に値を
取り出し、指定のテンプレートにはめ込んで出力するもの。
-----------------
@each(テンプレート名, 配列, 変数名)
-----------------
第2引数には、表示するデータをまとめた配列やコレクションを指定する。
第3引数には、配列から取り出したデータを代入する変数名を指定。
テンプレート側では、この変数を使ってデータを受取り、表示する。
----------------------------------
■@eachによる表示
-----------------
/* resources/views/components/item.blade.php */
<li>{[ $item['name'] }} [{{ $item['mail'] }}]</li>
-----------------
ここでは、$itemという変数から、nameとmailの値を取り出している。
つまり、nameとmailをまとめた配列データを、更に配列にまとめたものを用意するとい
うこと。
-----------------
/* resources/views/hello/index.blade.php */
@section('content')
  <p>ここが本文です。</p>
  <ul>
  @each('components.item', $data, $item')
  </ul>
@endsection
-----------------
@eachで、$dataという変数を'item'に入れて繰り返すようにしている。
ということは、アクションメソッドで$data変数を用意しておき、テンプレートに渡せ
ばよい。
-----------------
/* App/Http/Controllers/HelloController.php */
public function index()
{
  $data = [
    ['name'=>'山田太郎', 'mail'=>'taro@yamada'],
    ['name'=>'田中花子', 'mail'=>'hanako@flower'],
    ['name'=>'原田幸子', 'mail'=>'sachiko@happy'],
  ];
  return view('hello.index', ['data'=>$data]);
}
-----------------
$dataには、['name'=>'○○', 'mail'=>'○○']という形式の配列をデータとしてまと
めてある。
@eachでは、配列の要素1つ1つが取り出され、そこからnameとmailの値を取り出して、
項目として出力している。
-----------------
@eachは、テンプレート名を指定して呼び出すだけなので、新しいテンプレートを作成
したら、テンプレート名を書き換えるだけでデータの表示をがらりと変えることができ
る。
==================================

3-5 サービスとビューコンポーザ
ビューには、コントローラとは別に、ビジネスロジックを使って必要な情報などを処理
し、ビューにデータを結合する「ビューコンポーザ」という機能がある。

＠ビューコンポーザとは
Laravelでは、ビューテンプレートを利用して作成される。
Bladeでは、@phpディレクティブを利用することでスクリプトを埋め込むことができた
。
これによりビュー独自になんらかの処理が必要な場合もテンプレート側で処理を行うこ
とができる。
-----------------
が、テンプレートというものの役割を考えるとそこにビジネスロジックを含めるのはよ
くない。
といって、コントローラ側でビューのための処理を記述すのも変。
「ビューにビジネスロジックを持たせたい場合、どこに処理を置くべきか」というのは
、MVCアーキテクチャにおいて非常に悩ましい問題。
Laravelでは、この問題を解決するため、「ビューコンポーザ」という機能を提供して
いる。
----------------------------------
■ビューのビジネスロジック
ビューコンポーザは、ビューをレンダリングする際に、自動的に実行される処理を提供
するための部品。
関数やクラスとして用意できる。
ビューコンポーザを作成し、これをアプリケーションに登録することで、ビューをレン
ダリングする際に、常に処理を自動実行させることが可能となる。
-----------------
ビューコンポーザでは、ビューのオブジェクト（Viewクラス）が引数として渡され、テ
ンプレート側に必要な情報などを渡すことができる。
渡された値は、テンプレートで変数として利用できる。
==================================

＠サービスとサービスプロバイダ
ビューコンポーザを利用するためには、「サービス」「サービスプロバイダ」という仕
組みを理解する必要がある。
-----------------
サービスは、Laravelに用意されている機能強化の仕組み。
Laravelには、「サービスコンテナ」と呼ばれるシステムが用意されている。
これは、DI（Dependency Injection：依存性注入）と呼ばれる機能と使ったもので、必
要に応じて「サービス」と呼ばれるプログラムを自動的に自身の中に取り込み、使える
ようにしてくれるシステム。
このサービスとサービスコンテナにより、必要に応じて各種の機能をアプリケーション
内に組み込み、機能拡張することができるようになっている。
-----------------
このサービスを登録するために用意されているのが「サービスプロバイダ」。
サービスプロバイダを用意しておくことで、必要に応じて特定のサービスを組み込んで
使えるようにできる。
サービスプロバイダは、あらかじめ登録しておくための設定ファイルがあるので、そこ
に記述するだけでアプリケーションに組み込まれる。
----------------------------------
■サービスプロバイダとビューコンポーザ
サービスプロバイダとビューコンポーザは、Laravelで非常に重要な役割を果たす。
自身でサービスを定義し、組み込んだりすることも可能だが、サービスに限らず、アプ
リケーション内でさまざまな機能を実行するのにサービスプロバイダは利用されている
。
Laravelが提供する各種機能そのものの、サービスとサービスプロバイダの仕組みを利
用して作られていることが多い。
-----------------
ビューコンポーザは、アクセスしたページをレンダリングする際に必要な処理を自動的
に実行し、結果を組み込むことができる。
が、その仕組みはいつどうやってコントローラ内に組み込むのか、それを担うのがサー
ビスプロバイダ。
-----------------
まず、事前にサービスを登録するためのサービスプロバイダを用意しておき、その中で
ビューコンポーザを利用するための処理を記述しておく。
サービスプロバイダをアプリケーションに登録することで、記述されたビューコンポー
ザが自動実行されるようになる。
----------------------------------
■サービスプロバイダの定義
サービスプロバイダは、クラスとして定義される。
-----------------
use Illuminate\Support\Facades\View;
use Illuminate\Support\ServiceProvider;

class プロバイダクラス extends ServiceProvider
{
  public function register
  {
    // コンポーザの設定
  }
  public function boot
  {
    // コンポーザの設定
  }
}
-----------------
サービスプロバイダは、ServiceProviderクラスを継承して作成される。
これには、registerとbootというメソッドが用意されている。
-----------------
registerメソッドは、サービスプロバイダの登録処理を行う。
サービスを登録する処理などはここで行う。
-----------------
bootメソッドは、アプリケーションサービスへのブートストラップ処理（アプリケーシ
ョンが起動する際に割り込んで実行される処理）。
ここにコンポーザを設定する処理を用意することで、設定したビューをレンダリングす
る際に、自動的にコンポーザが呼び出されるようになる。
-----------------
ServiceProviderクラスには、他にも各種めそが用意されているが、bootだけで、とり
あえずビューコンポーザの利用はできる。
==================================

＠HelloServiceProviderを作成する
artisanを利用すれば簡単に作成できる。
-----------------
> php artisan make:provider HelloServiceProvider
----------------------------------
■HelloServiceProvider.phpをチェック
/* App/Providers/HelloServiceProvider.php */
<?php
namespace App\Providers;
use Illuminate\Support\ServiceProvider;

class HelloServiceProvider extends Provider
{ 
  public function boot()
  {
    //
  }
  
  public function register()
  {
    //
  }
}
-----------------
registerはサービスの登録。
bootメソッドは、アプリケーションサービスへのブートストラップ処理（アプリケーシ
ョンが起動する際に割り込んで実行される処理）。
==================================

＠クロージャでコンポーザ処理を作る
ビューコンポーザを作成する方法は2つ。
1つは、ビューコンポーザのクラスを定義し、それをbootで設定する方法。
もう1つは、boot内にクロージャでビューコンポーザの処理を組み込む方法。
-----------------
/* App/Providers/HelloServiceProvider.php */
<?php
namespace App\Providers;

use Iluminate\Support\Facedes\View;
use Iluminate\Support\ServiceProvider;

class HelloServiceProvider extends ServiceProvider
{
  public function boot()
  {
    Viwe::composer(
      'hello.index', function($view) {
        $view->with('view_message', 'composer message!');
      }
    );
  }
}
-----------------
ここでは、/hello/inde.blade.phpに「view_message」という値を設定する処理を行っ
ている。
----------------------------------
■View::composerについて
View::composerメソッドは、ビューコンポーザを設定するもの。
-----------------
View::composer(ビューの指定, 関数またはクラス）；
-----------------
第1引数には、ビューコンポーザを割り当てるビューを指定する。
第2引数には、実行する処理となる関数、またはビューコンポーザのクラスを指定する
。
-----------------
function($view) {
  $view->with('view_message', 'composer message!');
}
-----------------
引数の$viewは、Illuminaet\View名前空間にあるViewクラスのインスタンス。
これがビューをかんりするオブジェクト。
このオブジェクトのメソッドなどを利用して、ビューを操作することができる。
-----------------
withメソッドは、ビューに変数などを追加するもの。
-----------------
$view->with(変数名, 値);
-----------------
例ではview_messageという名前で、composer message!というテキストを値に設定して
いる。
----------------------------------
■サービスプロバイダの登録
HelloServiceProviderはできたが、この状態では動作しない。
サービスプロバイダをアプリケーションに登録する必要がある。
登録は、configフォルダ内にあるapp.phpを編集する。
-----------------
/* config/app.php */
'providers' => [
  Illuminate\Auth\AuthServiceProvder::class,
  Illuminate\Broadcasting\BroadcastServiceProvider::class,
  ...
],
-----------------
'provider'配列が、アプリケーションに登録されているプロバイダの一覧。
ここにサービスプロバイダクラスを追加すれば、アプリケーション起動時にそれが登録
され、利用できるようになる。
-----------------
'providers' => [
  ...
  App/Providers/HelloServiceProvider::class,
],
-----------------
これで、HelloServiceProgicerクラスがプロバイダとしてアプリケーションに登録され
る。
==================================

＠ビューコンポーザを利用する
/* resources/views/hello/index.blade.php */
@section('content')
  <p>ここが本文です。</p>
  <p>Controller value<br>'message' = {{ $message }}</p>
  <p>View composer value<br>'view_message' = {{ $view_message }}</p>
@enesection
-----------------
ここでは、{{ $message }}と{{ $view_message }}を埋め込んでいる。
$view_messageは、ビューコンポーザで値をビューに追加したもの。
$messageは、コントローラ側で用意する。
-----------------
/* App\Http\Controllers\HelloController.php */
public function index()
{
  return view('hello.index', ['message'=>'Hello!']);
}
-----------------
「/hello」にアクセスると、コントローラから渡された値と、ビューコンポーザから渡
された値を、ビュー（テンプレート）が受け取っていることが確認できる。
==================================

Chapter 4  リクエスト・レスポンスを補完する
4-1 ミドルウェアの利用

＠ミドルウェアとは
MVBアーキテクチャは、モデル・ビュー・コントローラがそれぞれ切り離されている。
基本部分はコントローラだが、コントローラはそれぞれのアクションとごに処理を行っ
ていく。
これは個別に処理を行えるという点は良いが、「すべてのアクセス時に何かを処理して
おく」という場合面倒くさいことになる。
-----------------
例えば、フォームに入力された値をチェックするような仕組み。
フォームのあるページが複数ある場合、アクション内で1つ1つチェック処理を書くのは
、効率的ではない。
-----------------
Laravelでは、コントローラとは別に、「指定のアドレスにリクエストが送られてきた
ら、自動的に何らかの処理を行う」という仕組みを提供している。
それが「ミドルウェア」。
----------------------------------
■ミドルウェアはアプリケーションの前にあるレイヤー
ミドルウェアとは、リクエストがコントローラのアクションに届く前（または後）に配
置されるレイヤーとなるプログラム。
-----------------
特定のアドレスにアクセスがあると、Laravelはルート情報を元に指定のアクションを
行う。
ミドルウェアはその前に割り込んで、アクションが実行される前（または後）に指定の
処理を行わせることができる。
-----------------
ミドルウェアの設定は、ルート情報を記述する際に指定できる。
コントローラのアクションで呼び出しているわけではない。
コントローラと完全に分離しているため、コントローラで行っている処理の内容には依
存しない。
==================================

＠ミドルウェアを作成する
ミドルウェアは、手作業でスクリプトを作成すれば作れるが、Artisanコマンドを使え
ば簡単に作成できる。
-----------------
> php artisan make:middleware HelloMiddleaware
----------------------------------
■HelloMiddleware.phpを確認する
ミドルウェアは、App/Http/Middlewareフォルダに作成される。
App/Http/Middlewareには、標準でいくつかのミドルウェアが入っている。
-----------------
/* App/Http/Middleware/HelloMiddleware.php */
<?php
namespace App\Http\Middleware;

use Closure;

class HelloMiddleware
{
  public function handle($request, Closure $next)
  {
    return $next($request);
  }
}
==================================

＠HelloMiddlewareクラス
-----------------
namespace App\Http\Middleware;
-----------------
app/Http/Middleware内に、スクリプトが置かれるので、namespaceを指定しておかない
と正しくクラスが動作しないので注意。
----------------------------------
■handleメソッドについて
HelloMiddlewareクラスには、handleメソッド1つが用意されている。
-----------------
public function handle($request, Closure $next)
{
  ...実行する処理...
}
-----------------
第1引数の$requestは、リクエスト情報を管理するRequestインスタンスが渡される。
$nextは、Closureクラスのインスタンス。
これはクロージャを渡すためのクラス。
$nextはクロージャになっており、これを呼び出して実行することで、ミドルウェアか
らアプリケーションへと送られるリクエスト（Requestオブジェクト）を作成すること
ができる。
==================================

＠HelloMiddlewareを修正する。
/* app/Http/Middleware/HelloMiccleware.php */
class HelloMiddleware
{
  public function handle($request, Closure $next)
  {
    $data = [
      ['name'=>'taro', 'mail'=>'taro@yamada'],
      ['name'=>'hanako', 'mail'=>'hanako@flower'],
      ['name'=>'sachiko', 'mail'=>'sachiko@happy'],
    ];
    $request->merge(['data'=>$data]);
    return $next($request);
  }
}
-----------------
mergeメソッドは以下のように利用する。
-----------------
$request->merge(配列);
-----------------
mergeは、フォーム送信などで送られる値（inputの値）に新たに値を追加するもの。
dataという名前で$dataの内容が追加される。
コントローラ側では、$request->dataで値を取り出せるようになる。
-----------------
次に、ミドルウェアを登録する。
app/Http/Kernel.phpの$routeMiddleware変数に以下を追加する。
-----------------
/* app/Http/Kernel.php */
'hello'=>\App\Http\Middleware\HelloMiddleware::class,
-----------------
これでHelloMiddlewareが登録され、利用可能となる。
==================================

＠ミドルウェアの実行
作成されたミドルウェアは、登録してもまだ利用はできない。
これを使うには、「利用するミドルウェアを呼び出す処理」の追記が必要となる。
これはルーティングの際に実行するのが一般的。
-----------------
/* routes/web.php */
// use App\Http\Middleware \HelloMiddleware;
Route::get('hello, [HelloController::class, 'index'])
  ->middleware(HelloMiddleware::class);
-----------------
ミドルウェアを利用する場合は、Route::getの後にメソッドチェーンを使って、middle
wareメソッドを追加する。
引数は利用するミドルウェアクラス。
middlewareメソッドは、メソッドチェーンとして連続して記述できる。
-----------------
Route::get(..)->middleware(...)->middleware(...);
==================================

＠ビューとコントローラの修正
ミドルウェアで組み込まれる$dataが正しく動いているか、ビューとコントローラを修
正する。
-----------------
/* app/Http/Controlers/HelloController.php */
public function index(Request $request)
{
  return view('hello.index', [
      'data'=>$request->data,
  ]);
}
-----------------
/* resources/views/hello/index.blade.php */
@section('content')
<p>ここが本文です。</p>
<table>
@foreach ($data in $item)
<tr><th>{{ $item['name'] }}</th><td>{{ $item['mail'] }}</td></tr>
@endroreach
</table>
@endsection
-----------------
ここでは、コントローラのアクションメソッドのviewの引数に['data'=>$request->d
ata]という形で、$request->dataの値を設定しておき、テンプレート側の@foreachで内
容を出力させている。
-----------------
配列としてデータを持たせているが、データベースを本格的に利用するようになると、
ミドルウェアを使って事前に必要なデータを処理できるため、コントローラの負担が軽
くなる。
==================================

＠リクエストとレスポンスの流れ
ミドルウェアは、アクション後の処理も作成することができる。
これには、ミドルウェアのhandleメソッドの引数として渡されるクロージャと、メソッ
ドの戻り値を理解する必要がある。
-----------------
public function handle($request, Closure $next)
{
  return $next($request);
}
-----------------
クロージャの戻り値がreturnされている。
この$nextで返されるのは、「レスポンス」インスタンス。
-----------------
リクエストが送られてきてから、クライアントにレスポンスが返されるまでの流れは以
下の通り。
1.リクエストが送られる
2.ミドルウェアのhandleが呼び出される
3.$nextを実行する。
これは、複数のミドルウェアが設定されている場合は、次のミドルウェアのhandleが呼
び出される。
他にミドルウェアがない場合は、コントローラのアクションが呼び出される。
4.アクションメソッドが終わるとともに、ページがレンダリングされ、レスポンスが生
成される。
この生成されたレスポンスが、$nextの戻り値として返される。
5.返されたレスポンスが、returnして返され、これがクライアントに返送される。
----------------------------------
■前処理と後処理
上記を考えると、コントローラの前に実行するミドルウェアと、後で実行するミドルウ
ェアの作成方法がわかる。
-----------------
■前処理
コントローラの前に実行する処理は、必要ｊな処理をすべて実行してから$nextを実行
し、それをreturnする。
-----------------
public function handle($request, Closure $next)
{
  ...処理を実行...
  return $next($request);
}
■後処理
コントローラの後に実行する処理は、$nextを実行してレスポンスを受け取ってから、
必要な処理を実行していく。
そして処理が終わったところで、保管してあったレスポンスをreturnする。
-----------------
public function handle($request, Closure $next)
{
  $response = $next($request);
  ...処理実行...
  return $response;
}
-----------------
このようにhandleメソッドの実装を変えることで、コントローラの前処理、後処理を作
成できる。
==================================

＠レスポンスを操作する
/* app/Http/Middleware/HelloMiddleware.php */
class HelloMiddleware
{
  public function($request, Closure $next)
  {
    $response = $next($request);
    $content = $response->content();
    
    $pattern = '/<middleware>(.*)</middleware>/i';
    $replace = '<a href="http://$1">$1</a>';
    $content = preg_replace($pattern, $replace, $content);
    
    $response->setContent($content);
    return $response;
  }
}
----------------------------------
■処理の流れ
まず最初に$nextを実行し、結果を$responseに格納する。
-----------------
$response = $next($request);
-----------------
これでコントローラのアクションが実行され、その結果のレスポンスが$responseに収
められる。
-----------------
$content = $resonse->content();
-----------------
$responseのcontentメソッドで、レスポンスに設定されているコンテンツが取得できる
。
これには、送り返されるHTMLコードが入っている。
そのコードの<middleware>というタグを置き換える。
-----------------
$pattern = '/<middleware>(.*)</middleware>/i';
$replace = '<a href="$1">$1</a>';
$content = preg_replace($pattern, $replace, $content);
-----------------
これにより、<middleware>というタグにドメイン名を書いておけば、リンクが自動生成
されるようになる。
-----------------
$response->setContent($content);
return $response;
-----------------
レスポンスのコンテンツ設定はsetContentメソッドで行う。
これによりクライアントに返送されるコンテンツが修正され、あとはレスポンスをretu
rnする。
----------------------------------
■ビューとコントローラの修正
/* resources/views/hello/index.blade.php */
@section('content')
  <p>ここが本文のコンテンツです。</p>
  <p>これは、<middleware>google.com</middleware>へのリンクです。</p>
  <p>これは、<mioddeware>yahoo.co.jp</middleware>へのリンクです。</p>
@endsection
-----------------
/* app/Http/Controllers/HelloController.pho */
public function index(Request $request)
{
  return view('hello.index');
}
-----------------
アクションでは特に何もしていない。
==================================

＠グローバルミドルウェア
特定のアクセスのみにミドルウェアを割り当てる場合は、1つ1つのルートに追記してい
く。
が、すべてのアクセスで自動的にミドルウェアを実行したい、という場合には、「グロ
ーバルミドルウェア」と呼ばれる機能を使う。
これはすべてのリクエストで利用可能となるもの。
----------------------------------
■グローバルミドルウェアの登録
ミドルウェアの登録は、app/Http/Kernal.phpで行う。
-----------------
/* app/Http/Kernal.php */
protected $middleware [
  \Illuminate\...\CheckForMaintenanceMode::class,
  \Illuminate\...\ValidatePostSize::class,
  ...
];
-----------------
グローバルミドルウェアは、Kernelクラスの$middleware変数の中に配列としてまとめ
られている。
-----------------
/* app/Http/Kernal.php */
protected $middleware [
  \Illuminate\...\CheckForMaintenanceMode::class,
  \Illuminate\...\ValidatePostSize::class,
  ...
  \App\Http\Middleware\HelloMiddleware::class,
];
-----------------
これでHelloMiddlewareが、グローバルミドルウェアとして登録される。
グローバルミドルウェアとして登録すると、個々のミドルウェアの呼び出し処理は不要となる。
-----------------
/* routes/web.php */
Route:get('hello', [HelloController::class, 'index']
  ->middlware(HelloMiddleware::class);
↓変更
Route::get('hello', [HelloController::class, 'index']);
-----------------
これで、HelloMiddlewareの呼び出し処理はなくなった。
が、グローバルミドルウェアとして登録しているので、/helloにアクセスすると、
同じ動作が行われる。
グローバルミドルウェアとして登録したことで、どこにアクセスしても常にミドルウェアが実行されるようになっている。
==================================

＠ミドルウェアのグループ登録
多数のミドルウェアを使うようになると、複数のミドルウェアを1つにまとめて使えるようになると便利。
ミドルウェアには、グループ化して登録するための仕組みも用意されている。
これは、Kernel.phpの「$middlewareGroups」変数で設定する。
-----------------
/* app/Http/Kernel.php */
protected $middlewareGroups = [
  'web' => [
    ...ミドルウェアクラス...
  ],
  'api' => [
    ...ミドルウェアクラス...
  ],
];
-----------------
$middlewareGroupsには、webとapiという項目があり、その中に、ミドルウェアクラスがまとめられている。
この'web'や'api'がグループ。
$middlewareGroupsでは、グループ名をキーとする値を用意し、そこにミドルウェアの配列を設定している。
それにより、その名前のグループが指定できる。
-----------------
グループ名は、ルーティング情報を設定するところでmiddlewareメソッドで設定できる。
----------------------------------
■グループを利用する
/* app/Http/Kernel.php */
$middlewareGroups = [
  ...
  'helo' => [
    \App\Http\Middleware\HelloMiddleware::class,
  ],
];
-----------------
グローバルミドルウェアの設定は削除しておく。
-----------------
/* routes/web.php */
Route::get('hello', [HelloController::class, 'index'])
  ->middleware('helo');
-----------------
これで、/helloにアクセスした際は、heloグループのすべてのミドルウェアが実行される。
==================================

4-2 バリデーション

＠バリデーション
フォーム等を使い、データを送信する場合、その値が正しい形式かを検証する必要がある。
それがバリデーション。
Laravelにはバリデーション機能が用意されており、値のチェックが行える。
==================================

＠ユーザ入力時の問題
一般に情報の入力にはフォームが多用されるが、フォームから送信された値をそのまま利用すると、問題を起こすことがある。
こうした問題の発生をチェックし、間違った部分があれば再入力を求めるなどの措置が必要。
この「入力された情報が正しい形式かどうかチェックする」ために提供されているのがバリデーション。
----------------------------------
■バリデーションとは
バリデーションとは、入力情報を検証する仕組み。
Laravelではさまざまなやり方で値の検証ができるが、もっとも簡単なのは、コントローラのvalidateメソッドを利用するやり方。
-----------------
これは、コントローラの基底クラス（Controller）に組み込まれているValidateRequestsというトレイト（メンバをまとめてクラスに追加するためのもの）に用意されている機能。
基本的にはコントローラクラスにあるメソッドと考えてよい。
validateは、アクションメソッドから次のように呼び出す。
-----------------
$this->validate($request, [検証設定の配列]);
-----------------
第1引数には、リクエスト。
第2引数に、検証する設定情報を配列としてまとめたものを用意する。
設定は「○○という項目に××という検証をする」というように、フォームのコントロール名と、そこに割り当てる検証ルールをセットにした形になっている。
-----------------
[ 
  '項目名' => '割り当てるルール',
  '項目名' => '割り当てるルール',
  ...
]
-----------------
フォームの項目ごとに、割り当てる検証ルールを配列にまとめたものをvalidateに渡せばよい。
================================

＠バリデーションを利用する
/* resources/views/hello/index.blade.php */
@section('content'
  <p>{{ $msg }}</p>
  <form action="/hello" method="post">
  <table>
    @csrf
    <tr>
    <th>name: </th>
    <td><input type="text" name="name"</td>
    </tr>
    <tr>
    <th>mail: </th>
    <td><input type="text" name="mail"></td>
    </tr>
    <tr>
    <th>age: </th>
    <td><input type="text" name="age"></td>
    </tr>
    <tr>
    <th></th>
    <td><input type="submit" value="send"></td>
    </tr>
  </table>
  </form>
@endsection
-----------------
3つのフィールドを用意してある。
----------------------------------
■HelloControllerの修正
/helloへのGETとPOSTのアクセスを行うメソッドを2つ用意する。
-----------------
/* app/Http/Contollers/HelloController.php */
class HelloController extends Controller
{
  public function index(Request $request)
  {
    return view('hello.index', ['msg'=>'フォームを入力：']);
  }
  public function post(Request $request)
  {
    $validate_rule = [
      'name' => 'required',
      'mail' => 'email',
      'age' => 'numeric|between:0,150',
    ];
    $this-validate($request, $validate_rule);
    return view('hello.index', ['msg'=>'正しく入力されました。']);
  }
}
-----------------
postメソッドが、POST送信されたときの処理。
-----------------
/* routes/web.php *
Route::get('hello', [HelloController::class, 'index']);
Route::post('hello', [HelloContoller::class, 'post']);
==================================

＠バリデーションの基本処理
$validate_rule = [
  'name' => 'required',
  'mail' => 'email',
  'age' => 'numeric|between:0,150',
];
-----------------
検証ルールは、このように配列の形でまとめる。
-----------------
'name'=>'required',
-----------------
nameフィールドに、requiredというルールをを設定している。
ルールは、|で結んで、複数設定できる。
-----------------
'age' => 'numeric|between:0,150',
-----------------
ageフィールドに、「数値である」「0～150の間の数字」という指定を設定。
----------------------------------
■バリデーションの実行
実際のバリデーションは、validateメソッドで行う。
-----------------
$this->validate($request, $validate_rule);
-----------------
これで検証ルールをつかってバリデーションが行われる。
----------------------------------
■バリデーションの結果のは寧
エラーかどうかをチェックして処理するのは、Laravelのバリデーション機能が自動で行っている。
validateを実行し、問題がなければ続きの処理を行う。
validateで問題が発生するとれいがいが発生し、その場でフォームページを表示するレスポンスが生成され、クライアントに返信される。
よって、その後に用意された処理は実行されず、フォームが再表示される。
==================================

＠エラーメッセージと値の保持
実用では、どんなエラーが発生しているのか、エラーメッセージを表示できなければならない。
どの項目を変更すべきかを伝えるため。
また、再入力の際は、前回の値がフィールドに設定されていると便利。
この2点を修正する。
-----------------
/* resources/views/hello/index.blade.php */
@section('content')
  <p>{{ $msg }}</p>
  @if (count($errors) >0)
  <div>
    <ul>
    @foreach ($errors->all() as $error)
      <li>{{ $error }}</li>
    @endforeach
   </ul>
  </div>
  @endif
  <form action="/hello" method="post">
  <table>
    @csrf
    <tr>
    <th>name: </th>
    <td>
      <input type="text" name="name" value="{{ old('name') }}">
    </td>
    </tr>
    <tr>
    <th>mail: </th>
    <td>
      <input type="text" name="mail" value="{{ old('mail') }}">
    </td>
    </tr>
    <tr>
    <th>age: </th>
    <td>
      <input type="text" name="age" value="{{ old('age') }}">
    </td>
    </tr>
    <tr>
    <th></th>
    <td><input type="submit" value="send"></td>
    </tr>
  </table>
  </form> 
@endsection
-----------------
エラーメッセージは英語なのだが、とりあえずエラーメッセージはすべて表示される。
----------------------------------
■エラーメッセージ表示の仕組み
-----------------
@if (count($errors) > 0)
  ...メッセージの表示処理
@endif
-----------------
$errorsという変数は、バリデーションで派生したエラーメッセージをまとめて管理するオブジェクト。
これはバリデーション機能に組み込まれており、コントローラで$errorsへの値の設定など行う必要はない。
何もしなくても、validateでバリデーションチェックをすれば、結果が$errors変数にまとめて保管される。
-----------------
$errors->all()は、エラーメッセージを配列にまとめて返す。
後は@foreachで表示させればよい。
----------------------------------
■前回送信した値
-----------------
value="{{ old('name') }}"
-----------------
oldメソッドは、引数に指定した入力項目の古い値（現在の値が設定される前の値）を返す。
これらは、いずれもコントローラでの作業は一切必要ない。
テンプレートだけで処理を行うことが可能。
----------------------------------

＠フィールドごとにエラーを表示
それぞれのフィールドで発生したエラーメッセージを表示した方がわかりやすい。
以下のようにする。
-----------------
/* resources/views/hello/index.blade.php */
@section('content')
  <p>{{ $msg }}</p>
  @if (count($errors) > 0)
  <p>入力に問題があります。再入力してください。</p>
  @endif
  <form action="/hello" method="post">
  <table>
    @csrf
    @if ($errors->has('name'))
    <tr>
    <th>error</th>
    <td>{{ $errors->first('name') }}</td>
    </tr>
    @endif
    <tr>
    <th>name: </th>
    <td><input type="text" name="name" value="{{ old('name') }}"></td>
    </tr>
    @if ($errors->has('mail')
    <tr>
    <th>ERROR</th>
    <td>{{ $errors->first('mail') }}</td>
    </tr>
    @endif
    <tr>
    <th>mail: </th>
    <td><input type="text" name="mail" value="{{ old('meil') }}"></td>
    </tr>
    @if ($errors->has('age'))
    <tr>
    <th>ERROR</th>
    <td>{{ $errors->first('age') }}</td>
    </tr>
    @endif
    <tr>
    <th>age: </th>
    <td><input type="text" name="age"  value="{{ old('age') }}"></td>
    </tr>
    <tr>
    <th></th>
    <td><input type="submit" value="send"></td>
    </tr>
  </table>
  </form>
@endsection
-----------------
こうすると、フィールド上にエラーメッセージが表示される。
----------------------------------
■firstでメッセージを取り出す
@if ($errors->has('name'))
<tr>
<th>ERROR</th>
<td>{{ $errors->first('name') }}</td>
</tr>
@endif
-----------------
$errors->hasは、エラーが発生しているかをチェックするメソッド
-----------------
$errors->has(項目名)
引数に指定した項目にエラーメッセージがあるかを調べる。
-----------------
$errors->firstは、指定した項目の最初のエラーメッセージを取得するもの
-----------------
$errors->first(項目名)
-----------------
これでエラーメッセージが取り出せる。
----------------------------------
■firstとget
firstで得られるのは、最初のエラーメッセージだけ。
項目に複数の検証ルールが設定されている場合、複数のエラーが発生することもある。
当然エラーメッセージも複数送られてくる。
-----------------
発生したエラーメッセージをすべて取得したい場合、getを使う。
-----------------
$変数 = $errors->get(項目名);
-----------------
これでエラーメッセージが配列にまとめて得られる。
----------------------------------
エラーメッセージを取得するには、all、first、getメソッドがあり、柔軟にエラーメッセージを取り出し処理できる。
==================================

＠@errorディレクティブを使う
@ifを使い$errors->hasがtrueなら、$errors->firstや$errors->getでエラーメッセージを表示することができるが、面倒。
Laravel5.8からは、エラーメッセージ専用のディレクティブが用意された。
それが@error。
----------------------------------
■エラーメッセージの表示
@error(名前）
...$messageでメッセージを表示
@enderror
-----------------
@errorディレクティブは、指定した名前の項目のエラーをチェックする。
エラーが発生していたら、ディレクティブ内に記述した内容を表示する。
@errorディレクティブ内では、発生したエラーメッセージが$messageという変数として渡される。
----------------------------------
■@errorを使ってみる
-----------------
/* resources/views/hello/index.blade.php */
@secion('content')
  <p>{{ $msg }}</p>
  @if (count($errors) > 0)
    <p>入力に問題があります。再入力してください。</p>
  @endif
  <form action="/hello" method="post">
  <table>
    @csrf
    @error('name')
      <tr>
      <th>ERROR</th>
      <td>{{ $message }}</td>
    </tr>
    @enderror
    <tr>
    <th>name: </th>
    <td><input type="text" name="name" value="{{ old('name') }}"></td>
    </tr>
    @error('mail')
    <tr>
    <th>ERROR</th>
    <td>{{ $message }}</td>
    </tr>
    @enderror
    <tr>
    <th>mail: </th>
    <td><input type="text" name="mail" value="{{ old('meil') }}"></td>
    </tr>
    @error('age')
    <tr>
    <th>ERROR</th>
    <td>{{ $message }}</td>
    </tr>
    @enderror
    <tr>
    <th>age: </th>
    <td><input type="text" name="age"  value="{{ old('age') }}"></td>
    </tr>
    <tr>
    <th></th>
    <td><input type="submit" value="send"></td>
    </tr>
  </table>
  </form>
@endsection
-----------------
@$error->firstと同じようにエラーが表示される。
-----------------
@error('name')
  <tr><th>ERROR</th>
  <td><td>{{ $message }}</td></tr>
@enderror
-----------------
$error('name')だけでエラーの発生をチェックし、{[ $message }}だけでエラーメッセージを表示している。
@errorを使うと、エラーメッセージの表示がスッキリシンプルになる。
==================================

＠バリデーションの検証ルール
以下Laravelの主な検証ルール。
-----------------
accept
その項目が、true、on、yes、1といった値かどうかをチェックする。
主にチェックボックスで用いる。
チェックされていればOK、いなければ不可、という処理。
-----------------
active_url
url
active_urlは、アドレスで指定されたドメインが実際に有効なものかをチェックする。
これは、dns_get_record関数でDNS情報を取得し、有効なIPアドレスかどうかをチェックしている。
urlは、単にurlの形式で書かれているかをチェックする。
-----------------
after: 日付
after_or_equal: 日付
afterは、指定した日付よりも後かどうかをチェックする。
after_or_equalは、指定した日付と同じかそれより後かをチェックする。
これらは、コロンの後に日付を表す文字列をつけて利用する。
あるいは、日付を乳路yくする他のフィールド名を指定することもできる。
-----------------
before: 日付
before_or_equal: 日付
afterの反対。
-----------------
alpha
alpha-dash
alpha-num
alphaは、入力テキストがすべてアルファベットであるかチェックする。
alpha-dashは、アルファベット＋ハイフン＋アンダースコアであるかをチェックする。
alpha-numは、アルファベットと数字であるかをチェックする。
-----------------
array
フィールドが配列となっているかをチェックする。
-----------------
bail
複数のバリデーションルールが2つの項目に適用されているとき、バリデーションエラーが派生したら、残りのバリデーションルールの適用を中断する。
-----------------
between: 最小値,最大値
数値のフィールドで用いるもので、値が指定の範囲内かどうかをチェックする。
-----------------
boolean
値が真偽値かどうかをチェックする。
true、false、0、1といった値を受け付ける。
それ以外は不可となる。
-----------------
confirmed
その項目が「項目名_conrirmation」という名前の項目と同じ値であるかチェックする。
例えば「passwd」という項目にconfirmedを設定したら、「passwd_conirmation」という項目と同じ値かどうかチェックする。
パスワードなど、同じ値を二重に入力する場合のチェックに用いられる。
-----------------
date
date_equals: 日付
date_format: フォーマット
dateは、入力テキストが日時の値として扱えるかどうかチェックする。
これは、strtotime関数でタイムスタンプに変換できればOK。
date_equalsは、入力テキストた指定の日付と同じ日付かをチェックする。
date_formatは、入力テキストが、指定フォーマットに一致しているかどうかをチェックする。
-----------------
different: フィールド
same: フィールド
指定されたフィールドと同じ値かどうかをチェックする。
differentは、異なる値であればOK。
sameは、同じ値ならＯＫ。
-----------------
digits: 桁数
digits_between: 最小桁数,最大桁数
数値で使う。
入力された値が、指定された桁数かどうかをチェックする。
digitsは指定の桁数ならＯＫ。
digits_betweenは、最小桁数～最大桁数の範囲内であればＯＫ。
-----------------
dimensions
イメージファイルなどを設定する場合に使う。
対象ファイルの内容が設定内容に合致するかどうかを示す。
設定内容は以下の通り
min_width, max_width    最小幅、最大幅
min_height, max_height  最小高さ、最大高さ
width, height  幅、高さ
_ratio_  縦横比
例えば「幅が50以上500以下」の場合は、「min-width=50,max-width=500」を設定する。
-----------------
distinct
配列項目で使う。
配列内に同じ値が無いかチェックする。
同じ値があれば不可。
-----------------
email
電子メールアドレスの形式かどうかチェック。
形式をチェックするだけで使えるかどうかはチェックしない。
-----------------
exists: テーブル,カラム
データベースを利用する場合に使われる。
入力値が、指定のデータベースの指定のカラムにあるかどうかをチェック。
あればＯＫ、なければ不可。
-----------------
file
type="file"などで用いる。
値がアップロードに成功したファイルであることを確認する。
-----------------
filled
required
filledは、その項目が空でない（何か入力がある）かチェックする。
未入力であれば不可。
requiredは、それが必須項目であることを示す。
入力されていればＯＫ。
-----------------
image
ファイルのフィールドで指定。
指定されたファイルがイメージファイルかどうかをチェック。
-----------------
gt: 項目
gte: 項目
lt: 項目
lte: 項目
指定した項目と値を比較する。
gtは>、gteは>=、ltは<、lteは<=。
例えば、「gt: A」とすれば、項目Aより大きいかどうかをチェックする。
比較する2つの項目は、同じタイプの入力項目である必要がある。
-----------------
in: 値1,値2...
not_in: 値1,値2...
inは、in:以降に用意した値に含まれているかをチェック。
含まれていればＯＫ。
not_inはその逆。
-----------------
integer
numeric
integerは、値が正数であるかをチェック。
numericは、値が数値であることをチェック。
-----------------
ip
ipv4
ipv6
値がIPアドレスかどうかをチェック。
ipは、IPアドレスであればＯＫ。
ipv4とipvv6はそれぞれIPv4またはIPv6の値かどうかをチェック。
-----------------
json
値がJSON形式の文字列かどうかをチェック。
-----------------
min: 値
max: 値
値が、指定よりも大きいか小さいかをチェック。
minは、指定の値より小さいか、maxは指定の値よりも大きいかをチェック。
最大最小を同時にチェックするにはbetweenを使う。
-----------------
mimetypes: タイプ名
mimes: タイプ名
type="file"などファイルを指定する項目で、その項目のMIMEタイプをチェックする。
mimetyupesは、"image/jpeg"といった形でタイプを指定。
mimesは、"jpeg"とタイプを指定する。
カンマ区切りで複数指定できる。
-----------------
regix: パターン
指定した正規表現にマッチするかをチェック。
マッチしなければ不可。
-----------------
nullable
nullが可能かどうか（必須項目でないか）をチェックする。
「nullを許可しているか」を調べる。
-----------------
password
Laravelのユーザー認証機能を利用している場合に使える。
認証されている利用者のパスワードと一致するかどうかをチェックする。
-----------------
present
この項目の値が存在することをチェックする。
存在していれば、値はnullでも問題ない。
-----------------
required
required_if: 項目,値
required_unless: 項目,値
required_with: 項目
required_with_all: 項目,項目,...
required_without: 項目置
required_without_all: 項目,項目...
必須項目に関するチェック。
required    必須項目である
required_if  指定した他の項目が指定の値と一致するときのみ必須項目扱いする
required_unless 指定の値が存在しないときのみそれ以外の指定項目を必須扱いにする
requried_with  指定した他の項目の値が存在するときのみ必須項目扱いにする
required_with_all  指定したすべての項目の値が存在するときのみ必須項目扱いする
required_without  指定した他の項目の値が存在しないときのみ必須項目扱いする。
requried_without_all  指定したすべての項目の値が存在しないときのみ必須項目扱いする
-----------------
starts_with: 値
ends_with: 値
項目の値が、指定の値で始まるかどうか、あるいは終るかどうかをチェックする。
-----------------
same: 項目
この項目の値が、指定の項目の値値一致するかどうかをチェックする。
-----------------
size: 値
値の大きさをチェックする。
文字列なら文字数、数値の場合は整数値、配列の場合は要素数をチェック。
指定の値と同じならOKとする。
-----------------
string
文字列の値かどうかをチェックする
-----------------
unique: テーブル,カラム
データベース利用の際に使う。
指定のテーブルの指定のカラムに同じ値が存在しないかをチェック。
==================================

4-3 バリデーションをカスタマイズする

＠フォームリクエストについて
validateを使ったバリデーションは、簡単にバリデーション機能を組み込めるが、問題もある。
コントローラ内に、手作業でバリデーション処理を書かなければならない。
アクションの処理をあれこれ編集する場合は、誤って、書き換えてしまう危険もある。
また、自分でバリデーションメソッドを呼び出して処理するのはあまりスマートではない。
-----------------
コントローラは、それぞれのアクションで実行すべきビジネスロジックなどを実行することになるため、「入力値のチェック」などは他に切り離したい。
そこでLaravelば「フォームリクエスト」という機能を提供している。
----------------------------------
■フォーム拡張リクエスト
フォームリクエストは、リクエストをフォーム利用のために拡張したもの。
Laravelでは、クライアントからのリクエストは、Requestクラスのインスタンスとして送られてくる。
このRequestを継承して作成されたのがFormRequest。
これを利用することで、フォームに関する機能をリクエストに組み込むことができる。
-----------------
送信されたフォームの内容をチェックするのは、コントローラより、リクエストの内部で処理してくれる、というのがスマート。
また、フォームリクエストは、バリデーション機能が組み込まれており、FormRequestを継承してカスタマイズすることで、きめ細かい操作が可能となる。
たとえば、英語のメッセージを日本語に変更することもできる。
==================================

＠フォームリクエストの作成
artisanを使って作成する。
-----------------
>php artisan make:request HelloRequest
-----------------
作成されたフォームリクエストは、app/Http/Requestsフォルダの中に作成される。
フォームリクエストは基本的にこのフォルダに配置する。
==================================

＠HelloRequestクラスの基本コード
/* app/Http/Requests/HelloRequest.php */
<?php
namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class HelloRequest extends FormRequest
{
  public function authorize()
  {
    return false;
  }
  public function rules()
  {
    return [
    //
    ];
  }
}
-----------------
フォームリクエストは、FormRequestクラスを継承して作成される。
FormRequestはRequestを継承しており、リクエスト機能をベースに、バリデーションなどの、フォームの処理に関する機能が追加されている。
-----------------
フォームリクエストには以下の2つのメソッドが用意されている。
■authorize
フォームリクエストを利用するアクションで、フォームリクエストの利用が許可されているかどうかを示すもの。
trueを返せば許可され、falseを返すと不許可になり、HttpException例外が発生してフォーム処理が行えなくなる。
■rules
適用されるバリデーションの検証ルールを設定する。
コントローラでvalidateメソッドを呼び出す第2引数に指定した、検証ルールと同じものを用意してreturnする。
returnされたルールを元に、FormRequestでバリデーションチェックが行われる。
この2つのメソッドを実装すれば、フォームリクエストは使えるようになる。
----------------------------------
■HelloRequestを修正する
/* app/Http/Requests/HelloRequest.php */
class HelloRequest extends FormRequest
{
  public function authorize()
  {
    if ($this->path() == 'hello')
    {
      return true;
    }
    else
    {
      return false;
    }
  }
}  
-----------------
まず、$this->pathでアクセスしたパスをチェック。
hello以外から利用できないようにしている。
-----------------
ruleメソッドでは、validateメソッドの例で使ったのと同じ検証ルールの配列を用意し、return。
これでname、mail、ageの各フィールドにルールが適用される。
----------------------------------
■アクションを修正する
/* app/Http/Controllers/HelloController.php */
use App\Http\Requests\HelloRequest;

public function post(HelloRequest $request)
{
  return view('hello.index', ['msg'=>'正しく入力されました！']);
}
-----------------
コントローラだけみれば、バリデーションに関する処理は見当たらない。
が、引数にHelloRequest（フォームリクエスト）が渡されており、HelloRequestに設定した内容を元にバリデーションが実行されるようになる。
==================================

＠メッセージのカスタイズ
これまでのエラーメッセージはすべて英語。
日本語で表示させるには、FormRequestのmessagesメソッドをオーバーライドする。
-----------------
/* app/Http/Requests/HelloRequest.php */
public function messages()
{
  return [
    'name.required' => '名前は必ず入力してください。',
    'mail.email' => 'メールアドレスが必要です。',
    'age.numeric' => '年齢を整数で記入ください。',
    'age.between' => '年齢は0～150の間で入力してください。',
  ];
}
-----------------
messagesメソッドは、FormRequestのバリデーション機能がエラーメッセージを必要としたときに呼び出されるメソッド。
「'項目名.ルール名'=>'メッセージ'」という形で、メッセージ情報を記述する。
複数のルールを設定している場合、1つ1つルールごとに記述する。
記述していないルールがあれば、英語のメッセージがそのまま使われる。
==================================

＠バリデータを作成する
バリデーション機能ではFormRequestに用意されているvaludateメソッドを使ってバリデーションが行われる。
validateではRequestインスタンスと検証ルールの引数を渡すことで自動的にフォームの値のチェックを行い、問題があれば、GETのページにリダイレクトしてフォームの再表示を行う。
が、場合によっては、エラーがあったら、フォームページにリダイレクトせず、別の処理を行わせたいこともあるはず。
このような場合には、バリデータを独自に用意して処理することもできる。
バリデータとは、バリデーションを行う機能のことで、LaravelではValidatorクラスとして用意されている。
コントローラのvaliateメソッドを呼び出さず、Valiatorクラスのインスタンスを作成して処理することで、バリデーションの処理をカスタマイズできる。
----------------------------------
■バリデータを使ってみる
バリデータは、送信されたフォームを受け取ったアクション内で作成し利用する。
-----------------
/* app/Http/Controllers/HelloController.php */
use Validator;
public function post(Request $request)
  $validator = Validator::make($request->all), [
    'name' => 'required',
    'mail' => 'email',
    'age' => 'numeric|between:0,150',
  ];
  if ($validator->fails()) {
    return redirect('/hello')
      ->withErrors($validator)
      ->withInput();
  }
  return view('hello.index', ['msg'=>'正しく入力されました。']);
}
----------------------------------
■バリデータ利用の基本
バリデータは、Validatorインスタンスを作成するだけで使えるようになる。
これはmakeメソッドを使って作成する。
-----------------
$validator = Validator::make(値の配列, ルールの配列);
第1引数には、チェックする値をまとめた配列を用意する。
フォームをそのままチェックするのであれば、$request->all()を指定する。
第2引数には、バリデータで使用する検証ルールの情報をまとめた配列。
-----------------
Validatorインスタンスを用意したら、後はエラーが起きたかチェックし、それに応じた処理を行えばよい。
エラーチェックは以下のように行う。
-----------------
if ($validator->failes()) { ...エラー時の処理.. }
-----------------
failes()は、Validatorのメソッドで、バリデーションチェックが失敗した（途中でエラーが発生した）かどうかを調べる
メソッド。
failes()がtrueを返した場合、エラーが発生しており、エラー時の処理を準備しておく。
同様に、チェックの結果を調べるメソッドとして、passesがあり、バリデーションチェックをパスしていいたらtrue、そうでないなら
falseを返す。
----------------------------------
■入力フォームへのリダイレクト
例ではエラー発生でGETのページ（/hello）にリダイレクトしている。
ただ、普通にリダイレクト下だけでは、エラーメッセージやフォームの値などを受け渡すことができない。
そこで、以下のようにする。
-----------------
return redirect('/hello)
  ->withErrors($validator)
  ->withInput();
-----------------
リダイレクトは、コントローラのredirectメソッドで行う。
指定のアドレスにリダイレクトするだけなら、redirectだけでよい。
エラーメッセージとフォームの入力情報をリダイレクトに際して追加するのが、withErrorsとwithInput。
withErrossは、引数にValidatorインスタンスを渡して、Validatorで発生したエラーメッセージをリダイレクト先まで引き継ぐことができる。
----------------------------------
＊validateのリダイレクトを使うには
コントローラでvalidateメソッドを呼び出してバリデーションを行わせると、自動的にリダイレクトして、フォームページに戻る。
この機能を利用したい場合は、Validatorのvalidateメソッドを呼び出せばよい。
これにより、再度バリデーションチェックが行われ、エラーがあればフォームページにリダイレクトされる。
ただし、この方法は、「フォーム以外の値をバリデーションチェックする」場合には正しく機能しない。
もともとフォームからPOST送信されていないので。
このような場合は、サイトのトップページにリダイレクトされる。
==================================

＠クエリ文字列にバリデータを適用する
バリデータを用意するやり方は、フォーム以外の値をチェックするのにも使える。
例としてクエリ文字列で渡された値をチェックするバリデータを作る。
-----------------
/* app/Http/Controllers/HelloController.php */
public function index(Request $request)
{
  $validator = Validator::make($request->query(), [
    'id' => 'required',
    'pass' => 'required',
  ]);
  if ($validator->fails()) {
    $msg = 'クエリーに問題があります。';
  }
  else {
    $msg = 'ID/PASSを受け付けました。フォームを入力ください。';
  }
  return view('hello.index', ['msg'=>$msg,]);
}
-----------------
ここでは、Validator::makeの引数に以下のような値を設定している。
-----------------
$reqest->query()
-----------------
Requestのqueryメソッドは、送信された文字列を配列の形にまとめたものを返す。
/hello?id=taro&pass=yamada
なら
['id'=>'taro', 'pass'=>'yamada']
このように、連想配列の形でまとめられたものを第1引数に指定すれば、それをバリデータでチェックできる。
==================================

＠エラーメッセージのカスタマイズ
バリデータを利用する場合、メッセージのカスタマイズも、Validator:makeで行える。
-----------------
$validator = Validator::make(値の配列, ルールの配列, メッセージの配列);
-----------------
第3引数に、エラーメッセージの配列を指定する。
これはフォームリクエストのmessagesでreturnしたものと同じ形式。
-----------------
/* app/Http/Controllers/HelloController.php */
public function post(Request $request)
{
  $rules = [
    'name' => 'required',
    'mail' => 'email',
    'age' => 'numeric|between:0,150',
  ];
  $messages = [
    'name.requred' => '名前は必ず入力してください。',
    'mail.email' => 'メールアドレスが必要です。',
    'age.numeric' => '年齢は整数で記入ください。',
    'age.between' => '年齢は0～150の間で入力ください。',
  ];
  $validator = Validator::make($request->query(), 
                               $rules,
                               $messages);
  if ($validator->fails()) {
    return redirect('/hello'
      ->withErrors($validator)
      ->withInput();
  }
  return view('hello.index', ['msg'=>'正しく入力されました。',]);
}
==================================

＠条件に応じてルールを追加する
検証ルールは、常に同じものが設定されるとは限らない。
状況に応じてルールを追加する必要がある場合もありえる。
-----------------
例えば、連絡先のラジオボタンに「メールアドレス」「電話番号」が用意され、その後のフィールドに連絡先情報を記入する、というようなフォーム。
連絡先情報が電話番号かメールアドレスか、ラジオボタンの選択によって異なる。
-----------------
このように、必要に応じてルールを追加したい場合、Validatorクラスのsometimesメソッドを利用できる。
sometimesメソッドは、処理を実行した結果によってあらたにルールを追加する。
-----------------
$validator->sometimes(項目名, ルール名, クロージャ);
-----------------
第3引数のクロージャで、ルールを追加すべきかを決定する。
クロージャは以下の形式。
-----------------
function($input) {
  ...処理を実行...
  return 真偽値;
}
-----------------
$inputには、入力された値をまとめたものが渡され、$input->nameといったふうにフォームの値を取り出すことができる。
戻り値は、ルールを追加すべきかを指定する真偽値。
trueの場合は何もしないが、falseの場合はsometimesで指定したルールを指定の項目に追加する。
-----------------
/* app/Http/Controllers/HelloConroller.php */
public function post(Request $request)
{
  $rules = [
    'name' => 'required',
    'mail' => 'email',
    'age' => 'numeric|between:0,150',
  ];
  $messages = [
    'name.required' => '名前は必ず入力してください。',
    'mail.email' => 'メールアドレスが必要です。',
    'age.numeric' => '年齢は整数で記入ください。',
    'age.max' => '年齢はゼロ歳以上で記入ください。',
    'age.min' => '年齢は200歳以下で黄乳液下さい。',
  ];
  $validator = Valiator::make($request->all(),
                              $rules,
                              $messages);
  $validator->sometimes('age', 'min:0', function($input) {
    return !is_int($int->age);
  });
  $validator->sometimes('age', 'max:200', function($input) {
    return !is_int($int->age);
  });
  if ($validator->fails()) {
    return redirectr('/hello')
      ->withErrors($validator)
      ->withInput();
  }
  return view('hello.index', ['msg' => '正しく入力されました。']);
}
-----------------
整数が入力されると、minとmaxのルールが追加される。
-----------------
$validator->sometimes('age', 'min:0', function($input) {
  return !is_int($input->age);
}
-----------------
クロージャで!is_int($input->name)の値を返している。
これにより、$input->ageが整数の場合はfalseが返され、ルールが追加される。
==================================

＠オリジナルバリデータの作成
バリデーションは、用意されているルールを指定して各種の検証を行う。
では、ルールそのものを新たに定義したい場合は？
いくつかの方法があり、その1つが「バリデータ」そのものを作成し、そこで独自に処理を定義する方法。
バリデータは、Illuminate\Validation\Validatorを継承したクラスとして作成する。
このクラスを作り、その中にバリデーションの処理を行うメソッドを作成すれば、それがバリデーションのルールとして利用できるようになる。
バリデーションクラスの基本形は以下の通り。
-----------------
use Illuminate\Validation\Validator;
class クラス名 extends Validator
{
  public function validate○○($attribute, $value, $parameters)
  {
    ...バリデーションの処理...
    return 真偽値;
  }
}
-----------------
Validatorの継承クラスを作成し、その中にvalidate○○というメソッドを用意する。
これがバリデーションで使われるルールとして認識される。
例えば「validateAbc」というメソッドを作成すれば、'abc'というルールとして扱われる。
-----------------
検証用のメソッドには、3つの引数が渡される。
第1引数は属性（設定したコントロール名など）、第2引数にチェックする値、第3引数にルールに渡されるパラメーター。
これらの値を元にバリデーションの処理を行い、真偽値を返す。
falseを返せばバリデーションエラー、trueの場合にはOK。
==================================

＠HelloValidatorを作成する。
バリデータっクラスには、コードを作成する機能はない。
手作業でスクリプトファイルを作成する必要がある。
-----------------
/* app/Http/Validators/HelloValidtor.php */
/* Validatorsフォルダは作成すること。*/
namespace App\Http\Validators;

use Illuminate\Validation\Validator;

class HelloValidator extends Validator
{
  public function validateHello($attribute, $value, $parameters)
  {
    return $value %  2 == 0;
  }
}
-----------------
'hello'というルールを定義している。
helloルールは、$value % 2 == 0の結果を返す、つまり、偶数ならOK。
----------------------------------
■HelloValidatorを組み込む
サービスプロバイダのbootのなかに以下を記述する。
-----------------
/* app/Providers/HelloServiceProvider.php */
use Validator;
use App\Http\Validators\HelloValidator;

public function boot()
{
  $validator = $this->app['validator'];
  $validator->resolver(function($translator, $data, $rules, $messages {
    return new HelloValidator($translator, $data, $rules, $messages);
  });
}
-----------------
バリデータは、$this->app['validator']というところに保管されている。
resolverメソッドで、リソルブ（バリデーションの処理を行う）の処理を設定できる。
引数には以下のようなクロージャを指定する。
-----------------
function($translator, $data, $rules, $messages) {
  return バリデータ;
}
-----------------
このクロージャは、Validatorインスタンスをreturnする。
HelloValidatorコンストラクタの引数には、resolverに渡された4つの引数をそのまま渡す。
これにより、HelloValidatorのメソッドがバリデーションの検証ルールとして追加される。
==================================

＠HelloValidatorのルールを使用する
/* app/Http/Requests/HelloRequest.php */
class HelloRequest extends FormRequest
{
  public function authorize()
  {
    if ($this->path() == 'hello')
    {
      return true;
    }
    else 
    {
      return false;
    }
  }
  public function rules()
  {
    return [
      'name' => 'required',
      'mail' => 'email',
      'age' => 'numeric|hello',
    ];
  }
  public function messages()
  {
    return [
      ...
      'age.hello' => 'Hello! 入力は偶数のみ受け付けます。',
    ];      
}
-----------------
ageにhelloルールを設定した。
-----------------
/* app/Httrp/Controllers/HelloController.php */
class HelloController extends Controller
{
  public function index(Request $request)
  {
    return view('hello.index', ['msg'=>'フォームにご入力ください。',]);
  }
  public function post(HelloRequest $request)
  {
    return view('hello.index', ['msg'=>'正しく入力されました。',]);
  }
}
-----------------
このように、オリジナルの検証ルールをValidatorクラスで作成して組み込めば、入力のチェックを拡張していくことができる。
==================================

＠バリデーションルールを作る
Validatoクラスを利用したバリデータは、サービスプロバイダのbootなどを組み込んで利用する。
が、手軽に利用する、という感じではない。
また、バリデータの仕組みがわかっていないと組み込めない。
----------------------------------
バリデータそのものを作成するやり方のほかに、バリデータで利用する「ルール」を作って利用する方法もある。
バリデーションルールは、Illuminate\Contracts\Validation名前空間の「Rule」クラスを継承して作られている。
Ruleを継承したクラスを作れば、それだけで、そのクラスをバリデーションのルールとして使えるようになる。
----------------------------------
バリデーションルールの作成は、以下のartisanコマンドを利用する。
-----------------
>php artisan make:rule Myrule
-----------------
これで、app/Rulesフォルダが作られ、その中にMyrule.phpが作られる。
artisan make:ruleは、ルールクラスのスクリプトファイルを生成するコマンドで、make:ruleの後にクラス名を指定して実行する。
----------------------------------
■生成されたRuleスクリプト
/* app/Rules/Myrule.php */
namespace App\Rules;
use Illuminate\Contracts\Validation\Rule;

class Myrule implements Rule
{
  public function __construct($n)
  {
    $this->num = $n;
    return $this->num . 'で割り切れる値が必要です。';
  }
  public function passes($attribute, $value)
  {
    return $value % $this->num == 0;
  }
  public function message()
  {
    return $this->num . 'で割り切れる値が必要です。';
  }    
}
-----------------
コンストラクタで整数値を渡し、それをnumプロパティに保管。
passesでは、入力された値がnumプロパティで割り切れる場合はtrue、そうでない場合はfalseを返す。
つまり、指定した値で割り切れる数値のみ入力できるようにするルール。
==================================

＠Myruleを使ってみる








  










 　